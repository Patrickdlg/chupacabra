// tslint:disable
/**
 * Matrix Client-Server API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: r0.6.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Used by servers to indicate that additional authentication information is required,
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * A list of the stages the client has completed successfully
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    completed?: Array<string>;
    /**
     * A list of the login flows supported by the server for this API.
     * @type {Array<AuthenticationResponseFlows>}
     * @memberof AuthenticationResponse
     */
    flows: Array<AuthenticationResponseFlows>;
    /**
     * Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here.
     * @type {{ [key: string]: object; }}
     * @memberof AuthenticationResponse
     */
    params?: { [key: string]: object; };
    /**
     * This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    session?: string;
}
/**
 *
 * @export
 * @interface AuthenticationResponseFlows
 */
export interface AuthenticationResponseFlows {
    /**
     * The login type of each of the stages required to complete this authentication flow
     * @type {Array<string>}
     * @memberof AuthenticationResponseFlows
     */
    stages: Array<string>;
}
/**
 *
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * The messages to send. A map from user ID, to a map from device ID to message body. The device ID may also be `*`, meaning all known devices for the user.
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof Body
     */
    messages?: { [key: string]: { [key: string]: object; }; };
}
/**
 * Describes which categories to search in and their criteria.
 * @export
 * @interface Categories
 */
export interface Categories {
    /**
     *
     * @type {RoomEventsCriteria}
     * @memberof Categories
     */
    room_events?: RoomEventsCriteria;
}
/**
 *
 * @export
 * @interface ConnectionInfo
 */
export interface ConnectionInfo {
    /**
     * Most recently seen IP address of the session.
     * @type {string}
     * @memberof ConnectionInfo
     */
    ip?: string;
    /**
     * Unix timestamp that the session was last active.
     * @type {number}
     * @memberof ConnectionInfo
     */
    last_seen?: number;
    /**
     * User agent string last seen in the session.
     * @type {string}
     * @memberof ConnectionInfo
     */
    user_agent?: string;
}
/**
 *
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * A user\'s sessions (i.e. what they did with an access token from one login).
     * @type {Array<SessionInfo>}
     * @memberof DeviceInfo
     */
    sessions?: Array<SessionInfo>;
}
/**
 * The event that matched.
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * The ID of the room associated with this event. Will not be present on events that arrive through ``/sync``, despite being required everywhere else.
     * @type {string}
     * @memberof Event
     */
    room_id: string;
}
/**
 * Context for result, if requested.
 * @export
 * @interface EventContext
 */
export interface EventContext {
    /**
     * Pagination token for the end of the chunk
     * @type {string}
     * @memberof EventContext
     */
    end?: string;
    /**
     * Events just after the result.
     * @type {Array<RoomEvent>}
     * @memberof EventContext
     */
    events_after?: Array<RoomEvent>;
    /**
     * Events just before the result.
     * @type {Array<RoomEvent>}
     * @memberof EventContext
     */
    events_before?: Array<RoomEvent>;
    /**
     * The historic profile information of the users that sent the events returned.  The ``string`` key is the user ID for which the profile belongs to.
     * @type {{ [key: string]: UserProfile; }}
     * @memberof EventContext
     */
    profile_info?: { [key: string]: UserProfile; };
    /**
     * Pagination token for the start of the chunk
     * @type {string}
     * @memberof EventContext
     */
    start?: string;
}
/**
 * Filter to apply to the results.
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * A string to search for in the room metadata, e.g. name, topic, canonical alias etc. (Optional).
     * @type {string}
     * @memberof Filter
     */
    generic_search_term?: string;
}
/**
 * Configuration for group.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Key that defines the group.
     * @type {string}
     * @memberof Group
     */
    key?: GroupKeyEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GroupKeyEnum {
    RoomId = 'room_id',
    Sender = 'sender'
}

/**
 * Requests that the server partitions the result set based on the provided list of keys.
 * @export
 * @interface Groupings
 */
export interface Groupings {
    /**
     * List of groups to request.
     * @type {Array<Group>}
     * @memberof Groupings
     */
    group_by?: Array<Group>;
}
/**
 * Configures whether any context for the events returned are included in the response.
 * @export
 * @interface IncludeEventContext
 */
export interface IncludeEventContext {
    /**
     * How many events after the result are returned. By default, this is ``5``.
     * @type {number}
     * @memberof IncludeEventContext
     */
    after_limit?: number;
    /**
     * How many events before the result are returned. By default, this is ``5``.
     * @type {number}
     * @memberof IncludeEventContext
     */
    before_limit?: number;
    /**
     * Requests that the server returns the historic profile information for the users that sent the events that were returned. By default, this is ``false``.
     * @type {boolean}
     * @memberof IncludeEventContext
     */
    include_profile?: boolean;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     *
     * @type {ThreePidCredentials}
     * @memberof InlineObject
     */
    three_pid_creds: ThreePidCredentials;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * The client secret used in the session with the identity server.
     * @type {string}
     * @memberof InlineObject1
     */
    client_secret: string;
    /**
     * An access token previously registered with the identity server.
     * @type {string}
     * @memberof InlineObject1
     */
    id_access_token: string;
    /**
     * The identity server to use.
     * @type {string}
     * @memberof InlineObject1
     */
    id_server: string;
    /**
     * The session identifier given by the identity server.
     * @type {string}
     * @memberof InlineObject1
     */
    sid: string;
}
/**
 *
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * Whether the room should be visible (public) in the directory or not (private).
     * @type {string}
     * @memberof InlineObject10
     */
    visibility: InlineObject10VisibilityEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject10VisibilityEnum {
    Public = 'public',
    Private = 'private'
}

/**
 *
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * The room ID to set.
     * @type {string}
     * @memberof InlineObject11
     */
    room_id: string;
}
/**
 *
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     *
     * @type {ThirdPartySigned}
     * @memberof InlineObject12
     */
    third_party_signed?: ThirdPartySigned;
}
/**
 *
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * The keys to be claimed. A map from user ID, to a map from device ID to algorithm name.
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof InlineObject13
     */
    one_time_keys: { [key: string]: { [key: string]: string; }; };
    /**
     * The time (in milliseconds) to wait when downloading keys from remote servers. 10 seconds is the recommended default.
     * @type {number}
     * @memberof InlineObject13
     */
    timeout?: number;
}
/**
 *
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * The keys to be downloaded. A map from user ID, to a list of device IDs, or to an empty list to indicate all devices for the corresponding user.
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InlineObject14
     */
    device_keys: { [key: string]: Array<string>; };
    /**
     * The time (in milliseconds) to wait when downloading keys from remote servers. 10 seconds is the recommended default.
     * @type {number}
     * @memberof InlineObject14
     */
    timeout?: number;
    /**
     * If the client is fetching keys as a result of a device update received in a sync request, this should be the \'since\' token of that sync request, or any later sync token. This allows the server to ensure its response contains the keys advertised by the notification in that sync.
     * @type {string}
     * @memberof InlineObject14
     */
    token?: string;
}
/**
 *
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * Identity keys for the device. May be absent if no new identity keys are required.
     * @type {object}
     * @memberof InlineObject15
     */
    device_keys?: object;
    /**
     * One-time public keys for \"pre-key\" messages.  The names of the properties should be in the format ``<algorithm>:<key_id>``. The format of the key is determined by the `key algorithm <#key-algorithms>`_.  May be absent if no new one-time keys are required.
     * @type {object}
     * @memberof InlineObject15
     */
    one_time_keys?: object;
}
/**
 *
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * Third party identifier for the user.  Deprecated in favour of ``identifier``.
     * @type {string}
     * @memberof InlineObject16
     */
    address?: string;
    /**
     * ID of the client device. If this does not correspond to a known client device, a new device will be created. The server will auto-generate a device_id if this is not specified.
     * @type {string}
     * @memberof InlineObject16
     */
    device_id?: string;
    /**
     *
     * @type {UserIdentifier}
     * @memberof InlineObject16
     */
    identifier?: UserIdentifier;
    /**
     * A display name to assign to the newly-created device. Ignored if ``device_id`` corresponds to a known device.
     * @type {string}
     * @memberof InlineObject16
     */
    initial_device_display_name?: string;
    /**
     * When logging in using a third party identifier, the medium of the identifier. Must be \'email\'.  Deprecated in favour of ``identifier``.
     * @type {string}
     * @memberof InlineObject16
     */
    medium?: string;
    /**
     * Required when ``type`` is ``m.login.password``. The user\'s password.
     * @type {string}
     * @memberof InlineObject16
     */
    password?: string;
    /**
     * Required when ``type`` is ``m.login.token``. Part of `Token-based`_ login.
     * @type {string}
     * @memberof InlineObject16
     */
    token?: string;
    /**
     * The login type being used.
     * @type {string}
     * @memberof InlineObject16
     */
    type: InlineObject16TypeEnum;
    /**
     * The fully qualified user ID or just local part of the user ID, to log in.  Deprecated in favour of ``identifier``.
     * @type {string}
     * @memberof InlineObject16
     */
    user?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject16TypeEnum {
    Password = 'm.login.password',
    Token = 'm.login.token'
}

/**
 *
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * The new presence state.
     * @type {string}
     * @memberof InlineObject17
     */
    presence: InlineObject17PresenceEnum;
    /**
     * The status message to attach to this state.
     * @type {string}
     * @memberof InlineObject17
     */
    status_msg?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject17PresenceEnum {
    Online = 'online',
    Offline = 'offline',
    Unavailable = 'unavailable'
}

/**
 *
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * The new avatar URL for this user.
     * @type {string}
     * @memberof InlineObject18
     */
    avatar_url?: string;
}
/**
 *
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * The new display name for this user.
     * @type {string}
     * @memberof InlineObject19
     */
    displayname?: string;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * The third party address being removed.
     * @type {string}
     * @memberof InlineObject2
     */
    address: string;
    /**
     * The identity server to unbind from. If not provided, the homeserver MUST use the ``id_server`` the identifier was added through. If the homeserver does not know the original ``id_server``, it MUST return a ``id_server_unbind_result`` of ``no-support``.
     * @type {string}
     * @memberof InlineObject2
     */
    id_server?: string;
    /**
     * The medium of the third party identifier being removed.
     * @type {string}
     * @memberof InlineObject2
     */
    medium: InlineObject2MediumEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject2MediumEnum {
    Email = 'email',
    Msisdn = 'msisdn'
}

/**
 *
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     *
     * @type {Filter}
     * @memberof InlineObject20
     */
    filter?: Filter;
    /**
     * Whether or not to include all known networks/protocols from application services on the homeserver. Defaults to false.
     * @type {boolean}
     * @memberof InlineObject20
     */
    include_all_networks?: boolean;
    /**
     * Limit the number of results returned.
     * @type {number}
     * @memberof InlineObject20
     */
    limit?: number;
    /**
     * A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms.  The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag.
     * @type {string}
     * @memberof InlineObject20
     */
    since?: string;
    /**
     * The specific third party network/protocol to request from the homeserver. Can only be used if ``include_all_networks`` is false.
     * @type {string}
     * @memberof InlineObject20
     */
    third_party_instance_id?: string;
}
/**
 *
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * A string that will allow the user to identify what application owns this pusher.
     * @type {string}
     * @memberof InlineObject21
     */
    app_display_name: string;
    /**
     * This is a reverse-DNS style identifier for the application. It is recommended that this end with the platform, such that different platform versions get different app identifiers. Max length, 64 chars.  If the ``kind`` is ``\"email\"``, this is ``\"m.email\"``.
     * @type {string}
     * @memberof InlineObject21
     */
    app_id: string;
    /**
     * If true, the homeserver should add another pusher with the given pushkey and App ID in addition to any others with different user IDs. Otherwise, the homeserver must remove any other pushers with the same App ID and pushkey for different users. The default is ``false``.
     * @type {boolean}
     * @memberof InlineObject21
     */
    append?: boolean;
    /**
     *
     * @type {PusherData1}
     * @memberof InlineObject21
     */
    data: PusherData1;
    /**
     * A string that will allow the user to identify what device owns this pusher.
     * @type {string}
     * @memberof InlineObject21
     */
    device_display_name: string;
    /**
     * The kind of pusher to configure. ``\"http\"`` makes a pusher that sends HTTP pokes. ``\"email\"`` makes a pusher that emails the user with unread notifications. ``null`` deletes the pusher.
     * @type {string}
     * @memberof InlineObject21
     */
    kind: string;
    /**
     * The preferred language for receiving notifications (e.g. \'en\' or \'en-US\').
     * @type {string}
     * @memberof InlineObject21
     */
    lang: string;
    /**
     * This string determines which set of device specific rules this pusher executes.
     * @type {string}
     * @memberof InlineObject21
     */
    profile_tag?: string;
    /**
     * This is a unique identifier for this pusher. The value you should use for this is the routing or destination address information for the notification, for example, the APNS token for APNS or the Registration ID for GCM. If your notification client has no such concept, use any unique identifier. Max length, 512 bytes.  If the ``kind`` is ``\"email\"``, this is the email address to send notifications to.
     * @type {string}
     * @memberof InlineObject21
     */
    pushkey: string;
}
/**
 *
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
    /**
     * The action(s) to perform when the conditions for this rule are met.
     * @type {Array<string>}
     * @memberof InlineObject22
     */
    actions: Array<InlineObject22ActionsEnum>;
    /**
     * The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to ``underride`` and ``override`` rules.
     * @type {Array<object>}
     * @memberof InlineObject22
     */
    conditions?: Array<object>;
    /**
     * Only applicable to ``content`` rules. The glob-style pattern to match against.
     * @type {string}
     * @memberof InlineObject22
     */
    pattern?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject22ActionsEnum {
    Notify = 'notify',
    DontNotify = 'dont_notify',
    Coalesce = 'coalesce',
    SetTweak = 'set_tweak'
}

/**
 *
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
    /**
     * The action(s) to perform for this rule.
     * @type {Array<string>}
     * @memberof InlineObject23
     */
    actions: Array<InlineObject23ActionsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject23ActionsEnum {
    Notify = 'notify',
    DontNotify = 'dont_notify',
    Coalesce = 'coalesce',
    SetTweak = 'set_tweak'
}

/**
 *
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
    /**
     * Whether the push rule is enabled or not.
     * @type {boolean}
     * @memberof InlineObject24
     */
    enabled: boolean;
}
/**
 *
 * @export
 * @interface InlineObject25
 */
export interface InlineObject25 {
    /**
     * Additional authentication information for the user-interactive authentication API. Note that this information is *not* used to define how the registered user should be authenticated, but is instead used to authenticate the ``register`` call itself.
     * @type {{ [key: string]: object; }}
     * @memberof InlineObject25
     */
    auth?: { [key: string]: object; };
    /**
     * ID of the client device. If this does not correspond to a known client device, a new device will be created. The server will auto-generate a device_id if this is not specified.
     * @type {string}
     * @memberof InlineObject25
     */
    device_id?: string;
    /**
     * If true, an ``access_token`` and ``device_id`` should not be returned from this call, therefore preventing an automatic login. Defaults to false.
     * @type {boolean}
     * @memberof InlineObject25
     */
    inhibit_login?: boolean;
    /**
     * A display name to assign to the newly-created device. Ignored if ``device_id`` corresponds to a known device.
     * @type {string}
     * @memberof InlineObject25
     */
    initial_device_display_name?: string;
    /**
     * The desired password for the account.
     * @type {string}
     * @memberof InlineObject25
     */
    password?: string;
    /**
     * The basis for the localpart of the desired Matrix ID. If omitted, the homeserver MUST generate a Matrix ID local part.
     * @type {string}
     * @memberof InlineObject25
     */
    username?: string;
}
/**
 *
 * @export
 * @interface InlineObject26
 */
export interface InlineObject26 {
    /**
     * The reason the user has been banned. This will be supplied as the ``reason`` on the target\'s updated `m.room.member`_ event.
     * @type {string}
     * @memberof InlineObject26
     */
    reason?: string;
    /**
     * The fully qualified user ID of the user being banned.
     * @type {string}
     * @memberof InlineObject26
     */
    user_id: string;
}
/**
 *
 * @export
 * @interface InlineObject27
 */
export interface InlineObject27 {
    /**
     * The invitee\'s third party identifier.
     * @type {string}
     * @memberof InlineObject27
     */
    address: string;
    /**
     * An access token previously registered with the identity server. Servers can treat this as optional to distinguish between r0.5-compatible clients and this specification version.
     * @type {string}
     * @memberof InlineObject27
     */
    id_access_token: string;
    /**
     * The hostname+port of the identity server which should be used for third party identifier lookups.
     * @type {string}
     * @memberof InlineObject27
     */
    id_server: string;
    /**
     * The kind of address being passed in the address field, for example ``email``.
     * @type {string}
     * @memberof InlineObject27
     */
    medium: string;
}
/**
 *
 * @export
 * @interface InlineObject28
 */
export interface InlineObject28 {
    /**
     * The fully qualified user ID of the invitee.
     * @type {string}
     * @memberof InlineObject28
     */
    user_id: string;
}
/**
 *
 * @export
 * @interface InlineObject29
 */
export interface InlineObject29 {
    /**
     *
     * @type {ThirdPartySigned}
     * @memberof InlineObject29
     */
    third_party_signed?: ThirdPartySigned;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * The third party address being removed.
     * @type {string}
     * @memberof InlineObject3
     */
    address: string;
    /**
     * The identity server to unbind from. If not provided, the homeserver MUST use the ``id_server`` the identifier was added through. If the homeserver does not know the original ``id_server``, it MUST return a ``id_server_unbind_result`` of ``no-support``.
     * @type {string}
     * @memberof InlineObject3
     */
    id_server?: string;
    /**
     * The medium of the third party identifier being removed.
     * @type {string}
     * @memberof InlineObject3
     */
    medium: InlineObject3MediumEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject3MediumEnum {
    Email = 'email',
    Msisdn = 'msisdn'
}

/**
 *
 * @export
 * @interface InlineObject30
 */
export interface InlineObject30 {
    /**
     * The reason the user has been kicked. This will be supplied as the ``reason`` on the target\'s updated `m.room.member`_ event.
     * @type {string}
     * @memberof InlineObject30
     */
    reason?: string;
    /**
     * The fully qualified user ID of the user being kicked.
     * @type {string}
     * @memberof InlineObject30
     */
    user_id: string;
}
/**
 *
 * @export
 * @interface InlineObject31
 */
export interface InlineObject31 {
    /**
     * The event ID the read marker should be located at. The event MUST belong to the room.
     * @type {string}
     * @memberof InlineObject31
     */
    m_fully_read: string;
    /**
     * The event ID to set the read receipt location at. This is equivalent to calling ``/receipt/m.read/$elsewhere:example.org`` and is provided here to save that extra call.
     * @type {string}
     * @memberof InlineObject31
     */
    m_read?: string;
}
/**
 *
 * @export
 * @interface InlineObject32
 */
export interface InlineObject32 {
    /**
     * The reason for the event being redacted.
     * @type {string}
     * @memberof InlineObject32
     */
    reason?: string;
}
/**
 *
 * @export
 * @interface InlineObject33
 */
export interface InlineObject33 {
    /**
     * The reason the content is being reported. May be blank.
     * @type {string}
     * @memberof InlineObject33
     */
    reason: string;
    /**
     * The score to rate this content as where -100 is most offensive and 0 is inoffensive.
     * @type {number}
     * @memberof InlineObject33
     */
    score: number;
}
/**
 *
 * @export
 * @interface InlineObject34
 */
export interface InlineObject34 {
    /**
     * The length of time in milliseconds to mark this user as typing.
     * @type {number}
     * @memberof InlineObject34
     */
    timeout?: number;
    /**
     * Whether the user is typing or not. If ``false``, the ``timeout`` key can be omitted.
     * @type {boolean}
     * @memberof InlineObject34
     */
    typing: boolean;
}
/**
 *
 * @export
 * @interface InlineObject35
 */
export interface InlineObject35 {
    /**
     * The fully qualified user ID of the user being unbanned.
     * @type {string}
     * @memberof InlineObject35
     */
    user_id: string;
}
/**
 *
 * @export
 * @interface InlineObject36
 */
export interface InlineObject36 {
    /**
     * The new version for the room.
     * @type {string}
     * @memberof InlineObject36
     */
    new_version: string;
}
/**
 *
 * @export
 * @interface InlineObject37
 */
export interface InlineObject37 {
    /**
     *
     * @type {Categories}
     * @memberof InlineObject37
     */
    search_categories: Categories;
}
/**
 *
 * @export
 * @interface InlineObject38
 */
export interface InlineObject38 {
    /**
     * A number in a range ``[0,1]`` describing a relative position of the room under the given tag.
     * @type {number}
     * @memberof InlineObject38
     */
    order?: number;
}
/**
 *
 * @export
 * @interface InlineObject39
 */
export interface InlineObject39 {
    /**
     * The maximum number of results to return. Defaults to 10.
     * @type {number}
     * @memberof InlineObject39
     */
    limit?: number;
    /**
     * The term to search for
     * @type {string}
     * @memberof InlineObject39
     */
    search_term: string;
}
/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * Additional authentication information for the user-interactive authentication API.
     * @type {{ [key: string]: object; }}
     * @memberof InlineObject4
     */
    auth?: { [key: string]: object; };
    /**
     * The identity server to unbind all of the user\'s 3PIDs from. If not provided, the homeserver MUST use the ``id_server`` that was originally use to bind each identifier. If the homeserver does not know which ``id_server`` that was, it must return an ``id_server_unbind_result`` of ``no-support``.
     * @type {string}
     * @memberof InlineObject4
     */
    id_server?: string;
}
/**
 *
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * Additional authentication information for the user-interactive authentication API.
     * @type {{ [key: string]: object; }}
     * @memberof InlineObject5
     */
    auth?: { [key: string]: object; };
    /**
     * Whether the user\'s other access tokens, and their associated devices, should be revoked if the request succeeds. Defaults to true.  When ``false``, the server can still take advantage of `the soft logout method <#soft-logout>`_ for the user\'s remaining devices.
     * @type {boolean}
     * @memberof InlineObject5
     */
    logout_devices?: boolean;
    /**
     * The new password for the account.
     * @type {string}
     * @memberof InlineObject5
     */
    new_password: string;
}
/**
 *
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * Extra keys, such as ``m.federate``, to be added to the content of the `m.room.create`_ event. The server will clobber the following keys: ``creator``, ``room_version``. Future versions of the specification may allow the server to clobber other keys.
     * @type {object}
     * @memberof InlineObject6
     */
    creation_content?: object;
    /**
     * A list of state events to set in the new room. This allows the user to override the default state events set in the new room. The expected format of the state events are an object with type, state_key and content keys set.  Takes precedence over events set by ``preset``, but gets overriden by ``name`` and ``topic`` keys.
     * @type {Array<StateEvent>}
     * @memberof InlineObject6
     */
    initial_state?: Array<StateEvent>;
    /**
     * A list of user IDs to invite to the room. This will tell the server to invite everyone in the list to the newly created room.
     * @type {Array<string>}
     * @memberof InlineObject6
     */
    invite?: Array<string>;
    /**
     * A list of objects representing third party IDs to invite into the room.
     * @type {Array<Invite3pid>}
     * @memberof InlineObject6
     */
    invite_3pid?: Array<Invite3pid>;
    /**
     * This flag makes the server set the ``is_direct`` flag on the ``m.room.member`` events sent to the users in ``invite`` and ``invite_3pid``. See `Direct Messaging`_ for more information.
     * @type {boolean}
     * @memberof InlineObject6
     */
    is_direct?: boolean;
    /**
     * If this is included, an ``m.room.name`` event will be sent into the room to indicate the name of the room. See Room Events for more information on ``m.room.name``.
     * @type {string}
     * @memberof InlineObject6
     */
    name?: string;
    /**
     * The power level content to override in the default power level event. This object is applied on top of the generated `m.room.power_levels`_ event content prior to it being sent to the room. Defaults to overriding nothing.
     * @type {object}
     * @memberof InlineObject6
     */
    power_level_content_override?: object;
    /**
     * Convenience parameter for setting various default state events based on a preset.  If unspecified, the server should use the ``visibility`` to determine which preset to use. A visbility of ``public`` equates to a preset of ``public_chat`` and ``private`` visibility equates to a preset of ``private_chat``.
     * @type {string}
     * @memberof InlineObject6
     */
    preset?: InlineObject6PresetEnum;
    /**
     * The desired room alias **local part**. If this is included, a room alias will be created and mapped to the newly created room. The alias will belong on the *same* homeserver which created the room. For example, if this was set to \"foo\" and sent to the homeserver \"example.com\" the complete room alias would be ``#foo:example.com``.  The complete room alias will become the canonical alias for the room.
     * @type {string}
     * @memberof InlineObject6
     */
    room_alias_name?: string;
    /**
     * The room version to set for the room. If not provided, the homeserver is to use its configured default. If provided, the homeserver will return a 400 error with the errcode ``M_UNSUPPORTED_ROOM_VERSION`` if it does not support the room version.
     * @type {string}
     * @memberof InlineObject6
     */
    room_version?: string;
    /**
     * If this is included, an ``m.room.topic`` event will be sent into the room to indicate the topic for the room. See Room Events for more information on ``m.room.topic``.
     * @type {string}
     * @memberof InlineObject6
     */
    topic?: string;
    /**
     * A ``public`` visibility indicates that the room will be shown in the published room list. A ``private`` visibility will hide the room from the published room list. Rooms default to ``private`` visibility if this key is not included. NB: This should not be confused with ``join_rules`` which also uses the word ``public``.
     * @type {string}
     * @memberof InlineObject6
     */
    visibility?: InlineObject6VisibilityEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject6PresetEnum {
    PrivateChat = 'private_chat',
    PublicChat = 'public_chat',
    TrustedPrivateChat = 'trusted_private_chat'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineObject6VisibilityEnum {
    Public = 'public',
    Private = 'private'
}

/**
 *
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * Additional authentication information for the user-interactive authentication API.
     * @type {{ [key: string]: object; }}
     * @memberof InlineObject7
     */
    auth?: { [key: string]: object; };
    /**
     * The list of device IDs to delete.
     * @type {Array<string>}
     * @memberof InlineObject7
     */
    devices: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * The new display name for this device. If not given, the display name is unchanged.
     * @type {string}
     * @memberof InlineObject8
     */
    display_name?: string;
}
/**
 *
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * Additional authentication information for the user-interactive authentication API.
     * @type {{ [key: string]: object; }}
     * @memberof InlineObject9
     */
    auth?: { [key: string]: object; };
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Array<ThirdPartyIdentifier>}
     * @memberof InlineResponse200
     */
    threepids?: Array<ThirdPartyIdentifier>;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * An indicator as to whether or not the homeserver was able to unbind the 3PID from the identity server. ``success`` indicates that the indentity server has unbound the identifier whereas ``no-support`` indicates that the identity server refuses to support the request or the homeserver was not able to determine an identity server to unbind from.
     * @type {string}
     * @memberof InlineResponse2001
     */
    id_server_unbind_result: InlineResponse2001IdServerUnbindResultEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2001IdServerUnbindResultEnum {
    NoSupport = 'no-support',
    Success = 'success'
}

/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * The room ID for this room alias.
     * @type {string}
     * @memberof InlineResponse20010
     */
    room_id?: string;
    /**
     * A list of servers that are aware of this room alias.
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    servers?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * An array of events.
     * @type {Array<object>}
     * @memberof InlineResponse20011
     */
    chunk?: Array<object>;
    /**
     * A token which correlates to the last value in ``chunk``. This token should be used in the next request to ``/events``.
     * @type {string}
     * @memberof InlineResponse20011
     */
    end?: string;
    /**
     * A token which correlates to the first value in ``chunk``. This is usually the same token supplied to ``from=``.
     * @type {string}
     * @memberof InlineResponse20011
     */
    start?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body.
     * @type {object}
     * @memberof InlineResponse20012
     */
    content: object;
    /**
     * The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. \'com.example.subdomain.event.type\'
     * @type {string}
     * @memberof InlineResponse20012
     */
    type: string;
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * The global private data created by this user.
     * @type {Array<object>}
     * @memberof InlineResponse20013
     */
    account_data?: Array<object>;
    /**
     * A token which correlates to the last value in ``chunk``. This token should be used with the ``/events`` API to listen for new events.
     * @type {string}
     * @memberof InlineResponse20013
     */
    end: string;
    /**
     * A list of presence events.
     * @type {Array<object>}
     * @memberof InlineResponse20013
     */
    presence: Array<object>;
    /**
     *
     * @type {Array<RoomInfo>}
     * @memberof InlineResponse20013
     */
    rooms: Array<RoomInfo>;
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * The joined room ID.
     * @type {string}
     * @memberof InlineResponse20014
     */
    room_id: string;
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * The ID of each room in which the user has ``joined`` membership.
     * @type {Array<string>}
     * @memberof InlineResponse20015
     */
    joined_rooms: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * The Matrix User IDs of all users who updated their device identity keys.
     * @type {Array<string>}
     * @memberof InlineResponse20016
     */
    changed?: Array<string>;
    /**
     * The Matrix User IDs of all users who may have left all the end-to-end encrypted rooms they previously shared with the user.
     * @type {Array<string>}
     * @memberof InlineResponse20016
     */
    left?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers.  If the homeserver could be reached, but the user or device was unknown, no failure is recorded. Instead, the corresponding user or device is missing from the ``one_time_keys`` result.
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse20017
     */
    failures?: { [key: string]: object; };
    /**
     * One-time keys for the queried devices. A map from user ID, to a map from devices to a map from ``<algorithm>:<key_id>`` to the key object.  See the `key algorithms <#key-algorithms>`_ section for information on the Key Object format.
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse20017
     */
    one_time_keys: { [key: string]: object; };
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * Information on the queried devices. A map from user ID, to a map from device ID to device information.  For each device, the information returned will be the same as uploaded via ``/keys/upload``, with the addition of an ``unsigned`` property.
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof InlineResponse20018
     */
    device_keys?: { [key: string]: { [key: string]: object; }; };
    /**
     * If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers.  If the homeserver could be reached, but the user or device was unknown, no failure is recorded. Instead, the corresponding user or device is missing from the ``device_keys`` result.
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse20018
     */
    failures?: { [key: string]: object; };
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * For each key algorithm, the number of unclaimed one-time keys of that type currently held on the server for this device.
     * @type {{ [key: string]: number; }}
     * @memberof InlineResponse20019
     */
    one_time_key_counts: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * An indicator as to whether or not the identity server was able to unbind the 3PID. ``success`` indicates that the identity server has unbound the identifier whereas ``no-support`` indicates that the identity server refuses to support the request or the homeserver was not able to determine an identity server to unbind from.
     * @type {string}
     * @memberof InlineResponse2002
     */
    id_server_unbind_result: InlineResponse2002IdServerUnbindResultEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2002IdServerUnbindResultEnum {
    NoSupport = 'no-support',
    Success = 'success'
}

/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * The homeserver\'s supported login types
     * @type {Array<LoginFlow>}
     * @memberof InlineResponse20020
     */
    flows?: Array<LoginFlow>;
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * An access token for the account. This access token can then be used to authorize other requests.
     * @type {string}
     * @memberof InlineResponse20021
     */
    access_token?: string;
    /**
     * ID of the logged-in device. Will be the same as the corresponding parameter in the request, if one was specified.
     * @type {string}
     * @memberof InlineResponse20021
     */
    device_id?: string;
    /**
     * The server_name of the homeserver on which the account has been registered.  **Deprecated**. Clients should extract the server_name from ``user_id`` (by splitting at the first colon) if they require it. Note also that ``homeserver`` is not spelt this way.
     * @type {string}
     * @memberof InlineResponse20021
     */
    home_server?: string;
    /**
     * The fully-qualified Matrix ID that has been registered.
     * @type {string}
     * @memberof InlineResponse20021
     */
    user_id?: string;
    /**
     * Optional client configuration provided by the server. If present, clients SHOULD use the provided object to reconfigure themselves, optionally validating the URLs within. This object takes the same form as the one returned from .well-known autodiscovery.
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse20021
     */
    well_known?: { [key: string]: object; };
}
/**
 *
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * The token to supply in the ``from`` param of the next ``/notifications`` request in order to request more events. If this is absent, there are no more results.
     * @type {string}
     * @memberof InlineResponse20022
     */
    next_token?: string;
    /**
     * The list of events that triggered notifications.
     * @type {Array<Notification>}
     * @memberof InlineResponse20022
     */
    notifications: Array<Notification>;
}
/**
 *
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * Whether the user is currently active
     * @type {boolean}
     * @memberof InlineResponse20023
     */
    currently_active?: boolean;
    /**
     * The length of time in milliseconds since an action was performed by this user.
     * @type {number}
     * @memberof InlineResponse20023
     */
    last_active_ago?: number;
    /**
     * This user\'s presence.
     * @type {string}
     * @memberof InlineResponse20023
     */
    presence: InlineResponse20023PresenceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20023PresenceEnum {
    Online = 'online',
    Offline = 'offline',
    Unavailable = 'unavailable'
}

/**
 *
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * The user\'s avatar URL if they have set one, otherwise not present.
     * @type {string}
     * @memberof InlineResponse20024
     */
    avatar_url?: string;
    /**
     * The user\'s display name if they have set one, otherwise not present.
     * @type {string}
     * @memberof InlineResponse20024
     */
    displayname?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * The user\'s avatar URL if they have set one, otherwise not present.
     * @type {string}
     * @memberof InlineResponse20025
     */
    avatar_url?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * The user\'s display name if they have set one, otherwise not present.
     * @type {string}
     * @memberof InlineResponse20026
     */
    displayname?: string;
}
/**
 * A list of the rooms on the server.
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * A paginated chunk of public rooms.
     * @type {Array<PublicRoomsChunk>}
     * @memberof InlineResponse20027
     */
    chunk: Array<PublicRoomsChunk>;
    /**
     * A pagination token for the response. The absence of this token means there are no more results to fetch and the client should stop paginating.
     * @type {string}
     * @memberof InlineResponse20027
     */
    next_batch?: string;
    /**
     * A pagination token that allows fetching previous results. The absence of this token means there are no results before this batch, i.e. this is the first batch.
     * @type {string}
     * @memberof InlineResponse20027
     */
    prev_batch?: string;
    /**
     * An estimate on the total number of public rooms, if the server has an estimate.
     * @type {number}
     * @memberof InlineResponse20027
     */
    total_room_count_estimate?: number;
}
/**
 * A list of the rooms on the server.
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * A paginated chunk of public rooms.
     * @type {Array<PublicRoomsChunk>}
     * @memberof InlineResponse20028
     */
    chunk: Array<PublicRoomsChunk>;
    /**
     * A pagination token for the response. The absence of this token means there are no more results to fetch and the client should stop paginating.
     * @type {string}
     * @memberof InlineResponse20028
     */
    next_batch?: string;
    /**
     * A pagination token that allows fetching previous results. The absence of this token means there are no results before this batch, i.e. this is the first batch.
     * @type {string}
     * @memberof InlineResponse20028
     */
    prev_batch?: string;
    /**
     * An estimate on the total number of public rooms, if the server has an estimate.
     * @type {number}
     * @memberof InlineResponse20028
     */
    total_room_count_estimate?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * An array containing the current pushers for the user
     * @type {Array<Pusher>}
     * @memberof InlineResponse20029
     */
    pushers?: Array<Pusher>;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * An indicator as to whether or not the homeserver was able to unbind the user\'s 3PIDs from the identity server(s). ``success`` indicates that all identifiers have been unbound from the identity server while ``no-support`` indicates that one or more identifiers failed to unbind due to the identity server refusing the request or the homeserver being unable to determine an identity server to unbind from. This must be ``success`` if the homeserver has no identifiers to unbind for the user.
     * @type {string}
     * @memberof InlineResponse2003
     */
    id_server_unbind_result: InlineResponse2003IdServerUnbindResultEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003IdServerUnbindResultEnum {
    Success = 'success',
    NoSupport = 'no-support'
}

/**
 *
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * The global ruleset.
     * @type {object}
     * @memberof InlineResponse20030
     */
    global: object;
}
/**
 * The push rule.
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * The actions to perform when this rule is matched.
     * @type {Array<string>}
     * @memberof InlineResponse20031
     */
    actions: Array<string>;
    /**
     * The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to ``underride`` and ``override`` rules.
     * @type {Array<object>}
     * @memberof InlineResponse20031
     */
    conditions?: Array<object>;
    /**
     * Whether this is a default rule, or has been set explicitly.
     * @type {boolean}
     * @memberof InlineResponse20031
     */
    _default: boolean;
    /**
     * Whether the push rule is enabled or not.
     * @type {boolean}
     * @memberof InlineResponse20031
     */
    enabled: boolean;
    /**
     * The glob-style pattern to match against.  Only applicable to ``content`` rules.
     * @type {string}
     * @memberof InlineResponse20031
     */
    pattern?: string;
    /**
     * The ID of this rule.
     * @type {string}
     * @memberof InlineResponse20031
     */
    rule_id: string;
}
/**
 *
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * The action(s) to perform for this rule.
     * @type {Array<string>}
     * @memberof InlineResponse20032
     */
    actions: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * Whether the push rule is enabled or not.
     * @type {boolean}
     * @memberof InlineResponse20033
     */
    enabled: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * An access token for the account. This access token can then be used to authorize other requests. Required if the ``inhibit_login`` option is false.
     * @type {string}
     * @memberof InlineResponse20034
     */
    access_token?: string;
    /**
     * ID of the registered device. Will be the same as the corresponding parameter in the request, if one was specified. Required if the ``inhibit_login`` option is false.
     * @type {string}
     * @memberof InlineResponse20034
     */
    device_id?: string;
    /**
     * The server_name of the homeserver on which the account has been registered.  **Deprecated**. Clients should extract the server_name from ``user_id`` (by splitting at the first colon) if they require it. Note also that ``homeserver`` is not spelt this way.
     * @type {string}
     * @memberof InlineResponse20034
     */
    home_server?: string;
    /**
     * The fully-qualified Matrix user ID (MXID) that has been registered.  Any user ID returned by this API must conform to the grammar given in the `Matrix specification <../appendices.html#user-identifiers>`_.
     * @type {string}
     * @memberof InlineResponse20034
     */
    user_id: string;
}
/**
 *
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * A flag to indicate that the username is available. This should always be ``true`` when the server replies with 200 OK.
     * @type {boolean}
     * @memberof InlineResponse20035
     */
    available?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * The server\'s local aliases on the room. Can be empty.
     * @type {Array<string>}
     * @memberof InlineResponse20036
     */
    aliases: Array<string>;
}
/**
 * The events and state surrounding the requested event.
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * A token that can be used to paginate forwards with.
     * @type {string}
     * @memberof InlineResponse20037
     */
    end?: string;
    /**
     * Details of the requested event.
     * @type {object}
     * @memberof InlineResponse20037
     */
    event?: object;
    /**
     * A list of room events that happened just after the requested event, in chronological order.
     * @type {Array<object>}
     * @memberof InlineResponse20037
     */
    events_after?: Array<object>;
    /**
     * A list of room events that happened just before the requested event, in reverse-chronological order.
     * @type {Array<object>}
     * @memberof InlineResponse20037
     */
    events_before?: Array<object>;
    /**
     * A token that can be used to paginate backwards with.
     * @type {string}
     * @memberof InlineResponse20037
     */
    start?: string;
    /**
     * The state of the room at the last event returned.
     * @type {Array<object>}
     * @memberof InlineResponse20037
     */
    state?: Array<object>;
}
/**
 *
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * A map from user ID to a RoomMember object.
     * @type {{ [key: string]: RoomMember; }}
     * @memberof InlineResponse20038
     */
    joined?: { [key: string]: RoomMember; };
}
/**
 *
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     *
     * @type {Array<object>}
     * @memberof InlineResponse20039
     */
    chunk?: Array<object>;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * The user id that owns the access token.
     * @type {string}
     * @memberof InlineResponse2004
     */
    user_id: string;
}
/**
 * A list of messages with a new token to request more.
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * A list of room events. The order depends on the ``dir`` parameter. For ``dir=b`` events will be in reverse-chronological order, for ``dir=f`` in chronological order, so that events start at the ``from`` point.
     * @type {Array<RoomEvent>}
     * @memberof InlineResponse20040
     */
    chunk?: Array<RoomEvent>;
    /**
     * The token the pagination ends at. If ``dir=b`` this token should be used again to request even earlier events.
     * @type {string}
     * @memberof InlineResponse20040
     */
    end?: string;
    /**
     * The token the pagination starts from. If ``dir=b`` this will be the token supplied in ``from``.
     * @type {string}
     * @memberof InlineResponse20040
     */
    start?: string;
    /**
     * A list of state events relevant to showing the ``chunk``. For example, if ``lazy_load_members`` is enabled in the filter then this may contain the membership events for the senders of events in the ``chunk``.  Unless ``include_redundant_members`` is ``true``, the server may remove membership events which would have already been sent to the client in prior calls to this endpoint, assuming the membership of those members has not changed.
     * @type {Array<object>}
     * @memberof InlineResponse20040
     */
    state?: Array<object>;
}
/**
 *
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * A unique identifier for the event.
     * @type {string}
     * @memberof InlineResponse20041
     */
    event_id?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * A unique identifier for the event.
     * @type {string}
     * @memberof InlineResponse20042
     */
    event_id: string;
}
/**
 *
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * The ID of the new room.
     * @type {string}
     * @memberof InlineResponse20043
     */
    replacement_room: string;
}
/**
 *
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * The global private data created by this user.
     * @type {object}
     * @memberof InlineResponse20044
     */
    account_data?: object;
    /**
     * Information on end-to-end device updates, as specified in |device_lists_sync|_.
     * @type {object}
     * @memberof InlineResponse20044
     */
    device_lists?: object;
    /**
     * Information on end-to-end encryption keys, as specified in |device_lists_sync|_.
     * @type {{ [key: string]: number; }}
     * @memberof InlineResponse20044
     */
    device_one_time_keys_count?: { [key: string]: number; };
    /**
     * The batch token to supply in the ``since`` param of the next ``/sync`` request.
     * @type {string}
     * @memberof InlineResponse20044
     */
    next_batch: string;
    /**
     * The updates to the presence status of other users.
     * @type {object}
     * @memberof InlineResponse20044
     */
    presence?: object;
    /**
     *
     * @type {Rooms}
     * @memberof InlineResponse20044
     */
    rooms?: Rooms;
    /**
     * Information on the send-to-device messages for the client device, as defined in |send_to_device_sync|_.
     * @type {object}
     * @memberof InlineResponse20044
     */
    to_device?: object;
}
/**
 *
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * The ID of the filter that was created. Cannot start with a ``{`` as this character is used to determine if the filter provided is inline JSON or a previously declared filter by homeservers on some APIs.
     * @type {string}
     * @memberof InlineResponse20045
     */
    filter_id: string;
}
/**
 *
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * The user account data that isn\'t associated with rooms to include.
     * @type {object}
     * @memberof InlineResponse20046
     */
    account_data?: object;
    /**
     * List of event fields to include. If this list is absent then all fields are included. The entries may include \'.\' characters to indicate sub-fields. So [\'content.body\'] will include the \'body\' field of the \'content\' object. A literal \'.\' character in a field name may be escaped using a \'\\\\\'. A server may include more fields than were requested.
     * @type {Array<string>}
     * @memberof InlineResponse20046
     */
    event_fields?: Array<string>;
    /**
     * The format to use for events. \'client\' will return the events in a format suitable for clients. \'federation\' will return the raw event as received over federation. The default is \'client\'.
     * @type {string}
     * @memberof InlineResponse20046
     */
    event_format?: InlineResponse20046EventFormatEnum;
    /**
     * The presence updates to include.
     * @type {object}
     * @memberof InlineResponse20046
     */
    presence?: object;
    /**
     *
     * @type {RoomFilter}
     * @memberof InlineResponse20046
     */
    room?: RoomFilter;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20046EventFormatEnum {
    Client = 'client',
    Federation = 'federation'
}

/**
 *
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * An access token the consumer may use to verify the identity of the person who generated the token. This is given to the federation API ``GET /openid/userinfo`` to verify the user\'s identity.
     * @type {string}
     * @memberof InlineResponse20047
     */
    access_token: string;
    /**
     * The number of seconds before this token expires and a new one must be generated.
     * @type {number}
     * @memberof InlineResponse20047
     */
    expires_in: number;
    /**
     * The homeserver domain the consumer should use when attempting to verify the user\'s identity.
     * @type {string}
     * @memberof InlineResponse20047
     */
    matrix_server_name: string;
    /**
     * The string ``Bearer``.
     * @type {string}
     * @memberof InlineResponse20047
     */
    token_type: string;
}
/**
 *
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     *
     * @type {{ [key: string]: Tag; }}
     * @memberof InlineResponse20048
     */
    tags?: { [key: string]: Tag; };
}
/**
 *
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * Indicates if the result list has been truncated by the limit.
     * @type {boolean}
     * @memberof InlineResponse20049
     */
    limited: boolean;
    /**
     * Ordered by rank and then whether or not profile info is available.
     * @type {Array<User>}
     * @memberof InlineResponse20049
     */
    results: Array<User>;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * Each key is an identifier for one of the user\'s devices.
     * @type {{ [key: string]: DeviceInfo; }}
     * @memberof InlineResponse2005
     */
    devices?: { [key: string]: DeviceInfo; };
    /**
     * The Matrix user ID of the user.
     * @type {string}
     * @memberof InlineResponse2005
     */
    user_id?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * The password to use.
     * @type {string}
     * @memberof InlineResponse20050
     */
    password: string;
    /**
     * The time-to-live in seconds
     * @type {number}
     * @memberof InlineResponse20050
     */
    ttl: number;
    /**
     * A list of TURN URIs
     * @type {Array<string>}
     * @memberof InlineResponse20050
     */
    uris: Array<string>;
    /**
     * The username to use.
     * @type {string}
     * @memberof InlineResponse20050
     */
    username: string;
}
/**
 *
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * Experimental features the server supports. Features not listed here, or the lack of this property all together, indicate that a feature is not supported.
     * @type {{ [key: string]: boolean; }}
     * @memberof InlineResponse20051
     */
    unstable_features?: { [key: string]: boolean; };
    /**
     * The supported versions.
     * @type {Array<string>}
     * @memberof InlineResponse20051
     */
    versions: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * The maximum size an upload can be in bytes. Clients SHOULD use this as a guide when uploading content. If not listed or null, the size limit should be treated as unknown.
     * @type {number}
     * @memberof InlineResponse20052
     */
    m_upload_size?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * The byte-size of the image. Omitted if there is no image attached.
     * @type {number}
     * @memberof InlineResponse20053
     */
    matriximagesize?: number;
    /**
     * An `MXC URI`_ to the image. Omitted if there is no image.
     * @type {string}
     * @memberof InlineResponse20053
     */
    ogimage?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * The `MXC URI`_ to the uploaded content.
     * @type {string}
     * @memberof InlineResponse20054
     */
    content_uri: string;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * The custom capabilities the server supports, using the Java package naming convention.
     * @type {{ [key: string]: object; }}
     * @memberof InlineResponse2006
     */
    capabilities: { [key: string]: object; };
}
/**
 * Information about the newly created room.
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * The created room\'s ID.
     * @type {string}
     * @memberof InlineResponse2007
     */
    room_id: string;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * A list of all registered devices for this user.
     * @type {Array<object>}
     * @memberof InlineResponse2008
     */
    devices?: Array<object>;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * Identifier of this device.
     * @type {string}
     * @memberof InlineResponse2009
     */
    device_id: string;
    /**
     * Display name set by the user for this device. Absent if no name has been set.
     * @type {string}
     * @memberof InlineResponse2009
     */
    display_name?: string;
    /**
     * The IP address where this device was last seen. (May be a few minutes out of date, for efficiency reasons).
     * @type {string}
     * @memberof InlineResponse2009
     */
    last_seen_ip?: string;
    /**
     * The timestamp (in milliseconds since the unix epoch) when this devices was last seen. (May be a few minutes out of date, for efficiency reasons).
     * @type {number}
     * @memberof InlineResponse2009
     */
    last_seen_ts?: number;
}
/**
 * A Matrix-level Error
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * An error code.
     * @type {string}
     * @memberof InlineResponse403
     */
    errcode: string;
    /**
     * A human-readable error message.
     * @type {string}
     * @memberof InlineResponse403
     */
    error?: string;
}
/**
 * The rate limit was reached for this request
 * @export
 * @interface InlineResponse429
 */
export interface InlineResponse429 {
    /**
     * The M_LIMIT_EXCEEDED error code
     * @type {string}
     * @memberof InlineResponse429
     */
    errcode: string;
    /**
     * A human-readable error message.
     * @type {string}
     * @memberof InlineResponse429
     */
    error?: string;
    /**
     * The amount of time in milliseconds the client should wait before trying the request again.
     * @type {number}
     * @memberof InlineResponse429
     */
    retry_after_ms?: number;
}
/**
 *
 * @export
 * @interface Invite3pid
 */
export interface Invite3pid {
    /**
     * The invitee\'s third party identifier.
     * @type {string}
     * @memberof Invite3pid
     */
    address: string;
    /**
     * An access token previously registered with the identity server. Servers can treat this as optional to distinguish between r0.5-compatible clients and this specification version.
     * @type {string}
     * @memberof Invite3pid
     */
    id_access_token: string;
    /**
     * The hostname+port of the identity server which should be used for third party identifier lookups.
     * @type {string}
     * @memberof Invite3pid
     */
    id_server: string;
    /**
     * The kind of address being passed in the address field, for example ``email``.
     * @type {string}
     * @memberof Invite3pid
     */
    medium: string;
}
/**
 * The state of a room that the user has been invited to. These state events may only have the ``sender``, ``type``, ``state_key`` and ``content`` keys present. These events do not replace any state that the client already has for the room, for example if the client has archived the room. Instead the client should keep two separate copies of the state: the one from the ``invite_state`` and one from the archived ``state``. If the client joins the room then the current state will be given as a delta against the archived ``state`` not the ``invite_state``.
 * @export
 * @interface InviteState
 */
export interface InviteState {
    /**
     * The StrippedState events that form the invite state.
     * @type {Array<StrippedState>}
     * @memberof InviteState
     */
    events?: Array<StrippedState>;
}
/**
 *
 * @export
 * @interface InvitedRoom
 */
export interface InvitedRoom {
    /**
     *
     * @type {InviteState}
     * @memberof InvitedRoom
     */
    invite_state?: InviteState;
}
/**
 *
 * @export
 * @interface JoinedRoom
 */
export interface JoinedRoom {
    /**
     * The private data that this user has attached to this room.
     * @type {object}
     * @memberof JoinedRoom
     */
    account_data?: object;
    /**
     * The ephemeral events in the room that aren\'t recorded in the timeline or state of the room. e.g. typing.
     * @type {object}
     * @memberof JoinedRoom
     */
    ephemeral?: object;
    /**
     * Updates to the state, between the time indicated by the ``since`` parameter, and the start of the ``timeline`` (or all state up to the start of the ``timeline``, if ``since`` is not given, or ``full_state`` is true).  N.B. state updates for ``m.room.member`` events will be incomplete if ``lazy_load_members`` is enabled in the ``/sync`` filter, and only return the member events required to display the senders of the timeline events in this response.
     * @type {object}
     * @memberof JoinedRoom
     */
    state?: object;
    /**
     *
     * @type {RoomSummary}
     * @memberof JoinedRoom
     */
    summary?: RoomSummary;
    /**
     * The timeline of messages and state changes in the room.
     * @type {object}
     * @memberof JoinedRoom
     */
    timeline?: object;
    /**
     *
     * @type {UnreadNotificationCounts}
     * @memberof JoinedRoom
     */
    unread_notifications?: UnreadNotificationCounts;
}
/**
 *
 * @export
 * @interface LeftRoom
 */
export interface LeftRoom {
    /**
     * The private data that this user has attached to this room.
     * @type {object}
     * @memberof LeftRoom
     */
    account_data?: object;
    /**
     * The state updates for the room up to the start of the timeline.
     * @type {object}
     * @memberof LeftRoom
     */
    state?: object;
    /**
     * The timeline of messages and state changes in the room up to the point when the user left.
     * @type {object}
     * @memberof LeftRoom
     */
    timeline?: object;
}
/**
 *
 * @export
 * @interface LoginFlow
 */
export interface LoginFlow {
    /**
     * The login type. This is supplied as the ``type`` when logging in.
     * @type {string}
     * @memberof LoginFlow
     */
    type?: string;
}
/**
 *
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * The action(s) to perform when the conditions for this rule are met. See `Push Rules: API`_.
     * @type {Array<string>}
     * @memberof Notification
     */
    actions: Array<string>;
    /**
     * The Event object for the event that triggered the notification.
     * @type {object}
     * @memberof Notification
     */
    event: object;
    /**
     * The profile tag of the rule that matched this event.
     * @type {string}
     * @memberof Notification
     */
    profile_tag?: string;
    /**
     * Indicates whether the user has sent a read receipt indicating that they have read this message.
     * @type {boolean}
     * @memberof Notification
     */
    read: boolean;
    /**
     * The ID of the room in which the event was posted.
     * @type {string}
     * @memberof Notification
     */
    room_id: string;
    /**
     * The unix timestamp at which the event notification was sent, in milliseconds.
     * @type {number}
     * @memberof Notification
     */
    ts: number;
}
/**
 * The pagination chunk for this room.
 * @export
 * @interface PaginationChunk
 */
export interface PaginationChunk {
    /**
     * If the user is a member of the room this will be a list of the most recent messages for this room. If the user has left the room this will be the messages that preceeded them leaving. This array will consist of at most ``limit`` elements.
     * @type {Array<object>}
     * @memberof PaginationChunk
     */
    chunk: Array<object>;
    /**
     * A token which correlates to the last value in ``chunk``. Used for pagination.
     * @type {string}
     * @memberof PaginationChunk
     */
    end: string;
    /**
     * A token which correlates to the first value in ``chunk``. Used for pagination.
     * @type {string}
     * @memberof PaginationChunk
     */
    start: string;
}
/**
 *
 * @export
 * @interface PublicRoomsChunk
 */
export interface PublicRoomsChunk {
    /**
     * Aliases of the room. May be empty.
     * @type {Array<string>}
     * @memberof PublicRoomsChunk
     */
    aliases?: Array<string>;
    /**
     * The URL for the room\'s avatar, if one is set.
     * @type {string}
     * @memberof PublicRoomsChunk
     */
    avatar_url?: string;
    /**
     * The canonical alias of the room, if any.
     * @type {string}
     * @memberof PublicRoomsChunk
     */
    canonical_alias?: string;
    /**
     * Whether guest users may join the room and participate in it. If they can, they will be subject to ordinary power level rules like any other user.
     * @type {boolean}
     * @memberof PublicRoomsChunk
     */
    guest_can_join: boolean;
    /**
     * The name of the room, if any.
     * @type {string}
     * @memberof PublicRoomsChunk
     */
    name?: string;
    /**
     * The number of members joined to the room.
     * @type {number}
     * @memberof PublicRoomsChunk
     */
    num_joined_members: number;
    /**
     * The ID of the room.
     * @type {string}
     * @memberof PublicRoomsChunk
     */
    room_id: string;
    /**
     * The topic of the room, if any.
     * @type {string}
     * @memberof PublicRoomsChunk
     */
    topic?: string;
    /**
     * Whether the room may be viewed by guest users without joining.
     * @type {boolean}
     * @memberof PublicRoomsChunk
     */
    world_readable: boolean;
}
/**
 *
 * @export
 * @interface Pusher
 */
export interface Pusher {
    /**
     * A string that will allow the user to identify what application owns this pusher.
     * @type {string}
     * @memberof Pusher
     */
    app_display_name: string;
    /**
     * This is a reverse-DNS style identifier for the application. Max length, 64 chars.
     * @type {string}
     * @memberof Pusher
     */
    app_id: string;
    /**
     *
     * @type {PusherData}
     * @memberof Pusher
     */
    data: PusherData;
    /**
     * A string that will allow the user to identify what device owns this pusher.
     * @type {string}
     * @memberof Pusher
     */
    device_display_name: string;
    /**
     * The kind of pusher. ``\"http\"`` is a pusher that sends HTTP pokes.
     * @type {string}
     * @memberof Pusher
     */
    kind: string;
    /**
     * The preferred language for receiving notifications (e.g. \'en\' or \'en-US\')
     * @type {string}
     * @memberof Pusher
     */
    lang: string;
    /**
     * This string determines which set of device specific rules this pusher executes.
     * @type {string}
     * @memberof Pusher
     */
    profile_tag?: string;
    /**
     * This is a unique identifier for this pusher. See ``/set`` for more detail. Max length, 512 bytes.
     * @type {string}
     * @memberof Pusher
     */
    pushkey: string;
}
/**
 * A dictionary of information for the pusher implementation itself.
 * @export
 * @interface PusherData
 */
export interface PusherData {
    /**
     * The format to use when sending notifications to the Push Gateway.
     * @type {string}
     * @memberof PusherData
     */
    format?: string;
    /**
     * Required if ``kind`` is ``http``. The URL to use to send notifications to.
     * @type {string}
     * @memberof PusherData
     */
    url?: string;
}
/**
 * A dictionary of information for the pusher implementation itself. If ``kind`` is ``http``, this should contain ``url`` which is the URL to use to send notifications to.
 * @export
 * @interface PusherData1
 */
export interface PusherData1 {
    /**
     * The format to send notifications in to Push Gateways if the ``kind`` is ``http``. The details about what fields the homeserver should send to the push gateway are defined in the `Push Gateway Specification`_. Currently the only format available is \'event_id_only\'.
     * @type {string}
     * @memberof PusherData1
     */
    format?: string;
    /**
     * Required if ``kind`` is ``http``. The URL to use to send notifications to. MUST be an HTTPS URL with a path of ``/_matrix/push/v1/notify``.
     * @type {string}
     * @memberof PusherData1
     */
    url?: string;
}
/**
 * The result object.
 * @export
 * @interface Result
 */
export interface Result {
    /**
     *
     * @type {EventContext}
     * @memberof Result
     */
    context?: EventContext;
    /**
     * A number that describes how closely this result matches the search. Higher is closer.
     * @type {number}
     * @memberof Result
     */
    rank?: number;
    /**
     *
     * @type {Event}
     * @memberof Result
     */
    result?: Event;
}
/**
 * Describes which categories to search in and their criteria.
 * @export
 * @interface ResultCategories
 */
export interface ResultCategories {
    /**
     *
     * @type {ResultRoomEvents}
     * @memberof ResultCategories
     */
    room_events?: ResultRoomEvents;
}
/**
 * Mapping of category name to search criteria.
 * @export
 * @interface ResultRoomEvents
 */
export interface ResultRoomEvents {
    /**
     * An approximate count of the total number of results found.
     * @type {number}
     * @memberof ResultRoomEvents
     */
    count?: number;
    /**
     * Any groups that were requested.  The outer ``string`` key is the group key requested (eg: ``room_id`` or ``sender``). The inner ``string`` key is the grouped value (eg: a room\'s ID or a user\'s ID).
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof ResultRoomEvents
     */
    groups?: { [key: string]: { [key: string]: object; }; };
    /**
     * List of words which should be highlighted, useful for stemming which may change the query terms.
     * @type {Array<string>}
     * @memberof ResultRoomEvents
     */
    highlights?: Array<string>;
    /**
     * Token that can be used to get the next batch of results, by passing as the `next_batch` parameter to the next call. If this field is absent, there are no more results.
     * @type {string}
     * @memberof ResultRoomEvents
     */
    next_batch?: string;
    /**
     * List of results in the requested order.
     * @type {Array<Result>}
     * @memberof ResultRoomEvents
     */
    results?: Array<Result>;
    /**
     * The current state for every room in the results. This is included if the request had the ``include_state`` key set with a value of ``true``.  The ``string`` key is the room ID for which the ``State Event`` array belongs to.
     * @type {{ [key: string]: Array<object>; }}
     * @memberof ResultRoomEvents
     */
    state?: { [key: string]: Array<object>; };
}
/**
 *
 * @export
 * @interface Results
 */
export interface Results {
    /**
     *
     * @type {ResultCategories}
     * @memberof Results
     */
    search_categories: ResultCategories;
}
/**
 * Room Events have the following fields.
 * @export
 * @interface RoomEvent
 */
export interface RoomEvent {
    /**
     * The ID of the room associated with this event. Will not be present on events that arrive through ``/sync``, despite being required everywhere else.
     * @type {string}
     * @memberof RoomEvent
     */
    room_id: string;
}
/**
 * Mapping of category name to search criteria.
 * @export
 * @interface RoomEventsCriteria
 */
export interface RoomEventsCriteria {
    /**
     *
     * @type {IncludeEventContext}
     * @memberof RoomEventsCriteria
     */
    event_context?: IncludeEventContext;
    /**
     * This takes a `filter`_.
     * @type {object}
     * @memberof RoomEventsCriteria
     */
    filter?: object;
    /**
     *
     * @type {Groupings}
     * @memberof RoomEventsCriteria
     */
    groupings?: Groupings;
    /**
     * Requests the server return the current state for each room returned.
     * @type {boolean}
     * @memberof RoomEventsCriteria
     */
    include_state?: boolean;
    /**
     * The keys to search. Defaults to all.
     * @type {Array<string>}
     * @memberof RoomEventsCriteria
     */
    keys?: Array<RoomEventsCriteriaKeysEnum>;
    /**
     * The order in which to search for results. By default, this is ``\"rank\"``.
     * @type {string}
     * @memberof RoomEventsCriteria
     */
    order_by?: RoomEventsCriteriaOrderByEnum;
    /**
     * The string to search events for
     * @type {string}
     * @memberof RoomEventsCriteria
     */
    search_term: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RoomEventsCriteriaKeysEnum {
    Body = 'content.body',
    Name = 'content.name',
    Topic = 'content.topic'
}
/**
    * @export
    * @enum {string}
    */
export enum RoomEventsCriteriaOrderByEnum {
    Recent = 'recent',
    Rank = 'rank'
}

/**
 * Filters to be applied to room data.
 * @export
 * @interface RoomFilter
 */
export interface RoomFilter {
    /**
     * The per user account data to include for rooms.
     * @type {object}
     * @memberof RoomFilter
     */
    account_data?: object;
    /**
     * The events that aren\'t recorded in the room history, e.g. typing and receipts, to include for rooms.
     * @type {object}
     * @memberof RoomFilter
     */
    ephemeral?: object;
    /**
     * Include rooms that the user has left in the sync, default false
     * @type {boolean}
     * @memberof RoomFilter
     */
    include_leave?: boolean;
    /**
     * A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``\'rooms\'`` filter. This filter is applied before the filters in ``ephemeral``, ``state``, ``timeline`` or ``account_data``
     * @type {Array<string>}
     * @memberof RoomFilter
     */
    not_rooms?: Array<string>;
    /**
     * A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ``ephemeral``, ``state``, ``timeline`` or ``account_data``
     * @type {Array<string>}
     * @memberof RoomFilter
     */
    rooms?: Array<string>;
    /**
     * The state events to include for rooms.
     * @type {object}
     * @memberof RoomFilter
     */
    state?: object;
    /**
     * The message and state update events to include for rooms.
     * @type {object}
     * @memberof RoomFilter
     */
    timeline?: object;
}
/**
 *
 * @export
 * @interface RoomInfo
 */
export interface RoomInfo {
    /**
     * The private data that this user has attached to this room.
     * @type {Array<object>}
     * @memberof RoomInfo
     */
    account_data?: Array<object>;
    /**
     * The invite event if ``membership`` is ``invite``
     * @type {object}
     * @memberof RoomInfo
     */
    invite?: object;
    /**
     * The user\'s membership state in this room.
     * @type {string}
     * @memberof RoomInfo
     */
    membership: RoomInfoMembershipEnum;
    /**
     *
     * @type {PaginationChunk}
     * @memberof RoomInfo
     */
    messages?: PaginationChunk;
    /**
     * The ID of this room.
     * @type {string}
     * @memberof RoomInfo
     */
    room_id: string;
    /**
     * If the user is a member of the room this will be the current state of the room as a list of events. If the user has left the room this will be the state of the room when they left it.
     * @type {Array<object>}
     * @memberof RoomInfo
     */
    state?: Array<object>;
    /**
     * Whether this room is visible to the ``/publicRooms`` API or not.\"
     * @type {string}
     * @memberof RoomInfo
     */
    visibility?: RoomInfoVisibilityEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RoomInfoMembershipEnum {
    Invite = 'invite',
    Join = 'join',
    Leave = 'leave',
    Ban = 'ban'
}
/**
    * @export
    * @enum {string}
    */
export enum RoomInfoVisibilityEnum {
    Private = 'private',
    Public = 'public'
}

/**
 *
 * @export
 * @interface RoomInfo1
 */
export interface RoomInfo1 {
    /**
     * The private data that this user has attached to this room.
     * @type {Array<object>}
     * @memberof RoomInfo1
     */
    account_data?: Array<object>;
    /**
     * The user\'s membership state in this room.
     * @type {string}
     * @memberof RoomInfo1
     */
    membership?: RoomInfo1MembershipEnum;
    /**
     *
     * @type {PaginationChunk}
     * @memberof RoomInfo1
     */
    messages?: PaginationChunk;
    /**
     * The ID of this room.
     * @type {string}
     * @memberof RoomInfo1
     */
    room_id: string;
    /**
     * If the user is a member of the room this will be the current state of the room as a list of events. If the user has left the room this will be the state of the room when they left it.
     * @type {Array<object>}
     * @memberof RoomInfo1
     */
    state?: Array<object>;
    /**
     * Whether this room is visible to the ``/publicRooms`` API or not.\"
     * @type {string}
     * @memberof RoomInfo1
     */
    visibility?: RoomInfo1VisibilityEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RoomInfo1MembershipEnum {
    Invite = 'invite',
    Join = 'join',
    Leave = 'leave',
    Ban = 'ban'
}
/**
    * @export
    * @enum {string}
    */
export enum RoomInfo1VisibilityEnum {
    Private = 'private',
    Public = 'public'
}

/**
 *
 * @export
 * @interface RoomMember
 */
export interface RoomMember {
    /**
     * The mxc avatar url of the user this object is representing.
     * @type {string}
     * @memberof RoomMember
     */
    avatar_url?: string;
    /**
     * The display name of the user this object is representing.
     * @type {string}
     * @memberof RoomMember
     */
    display_name?: string;
}
/**
 * Information about the room which clients may need to correctly render it to users.
 * @export
 * @interface RoomSummary
 */
export interface RoomSummary {
    /**
     * The users which can be used to generate a room name if the room does not have one. Required if the room\'s ``m.room.name`` or ``m.room.canonical_alias`` state events are unset or empty.  This should be the first 5 members of the room, ordered by stream ordering, which are joined or invited. The list must never include the client\'s own user ID. When no joined or invited members are available, this should consist of the banned and left users. More than 5 members may be provided, however less than 5 should only be provided when there are less than 5 members to represent.  When lazy-loading room members is enabled, the membership events for the heroes MUST be included in the ``state``, unless they are redundant. When the list of users changes, the server notifies the client by sending a fresh list of heroes. If there are no changes since the last sync, this field may be omitted.
     * @type {Array<string>}
     * @memberof RoomSummary
     */
    m_heroes?: Array<string>;
    /**
     * The number of users with ``membership`` of ``invite``. If this field has not changed since the last sync, it may be omitted. Required otherwise.
     * @type {number}
     * @memberof RoomSummary
     */
    m_invited_member_count?: number;
    /**
     * The number of users with ``membership`` of ``join``, including the client\'s own user ID. If this field has not changed since the last sync, it may be omitted. Required otherwise.
     * @type {number}
     * @memberof RoomSummary
     */
    m_joined_member_count?: number;
}
/**
 * Updates to rooms.
 * @export
 * @interface Rooms
 */
export interface Rooms {
    /**
     * The rooms that the user has been invited to, mapped as room ID to room information.
     * @type {{ [key: string]: InvitedRoom; }}
     * @memberof Rooms
     */
    invite?: { [key: string]: InvitedRoom; };
    /**
     * The rooms that the user has joined, mapped as room ID to room information.
     * @type {{ [key: string]: JoinedRoom; }}
     * @memberof Rooms
     */
    join?: { [key: string]: JoinedRoom; };
    /**
     * The rooms that the user has left or been banned from, mapped as room ID to room information.
     * @type {{ [key: string]: LeftRoom; }}
     * @memberof Rooms
     */
    leave?: { [key: string]: LeftRoom; };
}
/**
 *
 * @export
 * @interface SessionInfo
 */
export interface SessionInfo {
    /**
     * Information particular connections in the session.
     * @type {Array<ConnectionInfo>}
     * @memberof SessionInfo
     */
    connections?: Array<ConnectionInfo>;
}
/**
 *
 * @export
 * @interface StateEvent
 */
export interface StateEvent {
    /**
     * The content of the event.
     * @type {object}
     * @memberof StateEvent
     */
    content: object;
    /**
     * The state_key of the state event. Defaults to an empty string.
     * @type {string}
     * @memberof StateEvent
     */
    state_key?: string;
    /**
     * The type of event to send.
     * @type {string}
     * @memberof StateEvent
     */
    type: string;
}
/**
 * A stripped down state event, with only the ``type``, ``state_key``, ``sender``, and ``content`` keys.
 * @export
 * @interface StrippedState
 */
export interface StrippedState {
    /**
     * The ``content`` for the event.
     * @type {object}
     * @memberof StrippedState
     */
    content: object;
    /**
     * The ``sender`` for the event.
     * @type {string}
     * @memberof StrippedState
     */
    sender: string;
    /**
     * The ``state_key`` for the event.
     * @type {string}
     * @memberof StrippedState
     */
    state_key: string;
    /**
     * The ``type`` for the event.
     * @type {string}
     * @memberof StrippedState
     */
    type: string;
}
/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * A number in a range ``[0,1]`` describing a relative position of the room under the given tag.
     * @type {number}
     * @memberof Tag
     */
    order?: number;
}
/**
 *
 * @export
 * @interface ThirdPartyIdentifier
 */
export interface ThirdPartyIdentifier {
    /**
     * The timestamp, in milliseconds, when the homeserver associated the third party identifier with the user.
     * @type {number}
     * @memberof ThirdPartyIdentifier
     */
    added_at: number;
    /**
     * The third party identifier address.
     * @type {string}
     * @memberof ThirdPartyIdentifier
     */
    address: string;
    /**
     * The medium of the third party identifier.
     * @type {string}
     * @memberof ThirdPartyIdentifier
     */
    medium: ThirdPartyIdentifierMediumEnum;
    /**
     * The timestamp, in milliseconds, when the identifier was validated by the identity server.
     * @type {number}
     * @memberof ThirdPartyIdentifier
     */
    validated_at: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ThirdPartyIdentifierMediumEnum {
    Email = 'email',
    Msisdn = 'msisdn'
}

/**
 * A signature of an ``m.third_party_invite`` token to prove that this user owns a third party identity which has been invited to the room.
 * @export
 * @interface ThirdPartySigned
 */
export interface ThirdPartySigned {
    /**
     * The Matrix ID of the invitee.
     * @type {string}
     * @memberof ThirdPartySigned
     */
    mxid: string;
    /**
     * The Matrix ID of the user who issued the invite.
     * @type {string}
     * @memberof ThirdPartySigned
     */
    sender: string;
    /**
     * A signatures object containing a signature of the entire signed object.
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof ThirdPartySigned
     */
    signatures: { [key: string]: { [key: string]: string; }; };
    /**
     * The state key of the m.third_party_invite event.
     * @type {string}
     * @memberof ThirdPartySigned
     */
    token: string;
}
/**
 * The third party credentials to associate with the account.
 * @export
 * @interface ThreePidCredentials
 */
export interface ThreePidCredentials {
    /**
     * The client secret used in the session with the identity server.
     * @type {string}
     * @memberof ThreePidCredentials
     */
    client_secret: string;
    /**
     * An access token previously registered with the identity server. Servers can treat this as optional to distinguish between r0.5-compatible clients and this specification version.
     * @type {string}
     * @memberof ThreePidCredentials
     */
    id_access_token: string;
    /**
     * The identity server to use.
     * @type {string}
     * @memberof ThreePidCredentials
     */
    id_server: string;
    /**
     * The session identifier given by the identity server.
     * @type {string}
     * @memberof ThreePidCredentials
     */
    sid: string;
}
/**
 * Counts of unread notifications for this room. See the `Receiving notifications section <#receiving-notifications>`_ for more information on how these are calculated.
 * @export
 * @interface UnreadNotificationCounts
 */
export interface UnreadNotificationCounts {
    /**
     * The number of unread notifications for this room with the highlight flag set
     * @type {number}
     * @memberof UnreadNotificationCounts
     */
    highlight_count?: number;
    /**
     * The total number of unread notifications for this room
     * @type {number}
     * @memberof UnreadNotificationCounts
     */
    notification_count?: number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     * The avatar url, as an MXC, if one exists.
     * @type {string}
     * @memberof User
     */
    avatar_url?: string;
    /**
     * The display name of the user, if one exists.
     * @type {string}
     * @memberof User
     */
    display_name?: string;
    /**
     * The user\'s matrix user ID.
     * @type {string}
     * @memberof User
     */
    user_id: string;
}
/**
 * Identification information for the user.
 * @export
 * @interface UserIdentifier
 */
export interface UserIdentifier {
    /**
     * The type of identification.  See `Identifier types`_ for supported values and additional property descriptions.
     * @type {string}
     * @memberof UserIdentifier
     */
    type: string;
}
/**
 *
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    avatar_url?: string;
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    displayname?: string;
}

/**
 * ApplicationServiceRoomDirectoryManagementApi - axios parameter creator
 * @export
 */
export const ApplicationServiceRoomDirectoryManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the visibility of a given room on the application service\'s room directory.  This API is similar to the room directory visibility API used by clients to update the homeserver\'s more general room directory.  This API requires the use of an application service access token (``as_token``) instead of a typical client\'s access_token. This API cannot be invoked by users who are not identified as application services.
         * @summary Updates a room\'s visibility in the application service\'s room directory.
         * @param {string} networkId The protocol (network) ID to update the room list for. This would have been provided by the application service as being listed as a supported protocol.
         * @param {string} roomId The room ID to add to the directory.
         * @param {InlineObject10} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppserviceRoomDirectoryVsibility: async (networkId: string, roomId: string, body: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling updateAppserviceRoomDirectoryVsibility.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling updateAppserviceRoomDirectoryVsibility.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAppserviceRoomDirectoryVsibility.');
            }
            const localVarPath = `/_matrix/client/r0/directory/list/appservice/{networkId}/{roomId}`
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationServiceRoomDirectoryManagementApi - functional programming interface
 * @export
 */
export const ApplicationServiceRoomDirectoryManagementApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Updates the visibility of a given room on the application service\'s room directory.  This API is similar to the room directory visibility API used by clients to update the homeserver\'s more general room directory.  This API requires the use of an application service access token (``as_token``) instead of a typical client\'s access_token. This API cannot be invoked by users who are not identified as application services.
         * @summary Updates a room\'s visibility in the application service\'s room directory.
         * @param {string} networkId The protocol (network) ID to update the room list for. This would have been provided by the application service as being listed as a supported protocol.
         * @param {string} roomId The room ID to add to the directory.
         * @param {InlineObject10} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAppserviceRoomDirectoryVsibility(networkId: string, roomId: string, body: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await ApplicationServiceRoomDirectoryManagementApiAxiosParamCreator(configuration).updateAppserviceRoomDirectoryVsibility(networkId, roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApplicationServiceRoomDirectoryManagementApi - factory interface
 * @export
 */
export const ApplicationServiceRoomDirectoryManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Updates the visibility of a given room on the application service\'s room directory.  This API is similar to the room directory visibility API used by clients to update the homeserver\'s more general room directory.  This API requires the use of an application service access token (``as_token``) instead of a typical client\'s access_token. This API cannot be invoked by users who are not identified as application services.
         * @summary Updates a room\'s visibility in the application service\'s room directory.
         * @param {string} networkId The protocol (network) ID to update the room list for. This would have been provided by the application service as being listed as a supported protocol.
         * @param {string} roomId The room ID to add to the directory.
         * @param {InlineObject10} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppserviceRoomDirectoryVsibility(networkId: string, roomId: string, body: InlineObject10, options?: any): AxiosPromise<object> {
            return ApplicationServiceRoomDirectoryManagementApiFp(configuration).updateAppserviceRoomDirectoryVsibility(networkId, roomId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationServiceRoomDirectoryManagementApi - object-oriented interface
 * @export
 * @class ApplicationServiceRoomDirectoryManagementApi
 * @extends {BaseAPI}
 */
export class ApplicationServiceRoomDirectoryManagementApi extends BaseAPI {
    /**
     * Updates the visibility of a given room on the application service\'s room directory.  This API is similar to the room directory visibility API used by clients to update the homeserver\'s more general room directory.  This API requires the use of an application service access token (``as_token``) instead of a typical client\'s access_token. This API cannot be invoked by users who are not identified as application services.
     * @summary Updates a room\'s visibility in the application service\'s room directory.
     * @param {string} networkId The protocol (network) ID to update the room list for. This would have been provided by the application service as being listed as a supported protocol.
     * @param {string} roomId The room ID to add to the directory.
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationServiceRoomDirectoryManagementApi
     */
    public updateAppserviceRoomDirectoryVsibility(networkId: string, roomId: string, body: InlineObject10, options?: any) {
        return ApplicationServiceRoomDirectoryManagementApiFp(this.configuration).updateAppserviceRoomDirectoryVsibility(networkId, roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CapabilitiesApi - axios parameter creator
 * @export
 */
export const CapabilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets information about the server\'s supported feature set and other relevant capabilities.
         * @summary Gets information about the server\'s capabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCapabilities: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/capabilities`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CapabilitiesApi - functional programming interface
 * @export
 */
export const CapabilitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets information about the server\'s supported feature set and other relevant capabilities.
         * @summary Gets information about the server\'s capabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCapabilities(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await CapabilitiesApiAxiosParamCreator(configuration).getCapabilities(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CapabilitiesApi - factory interface
 * @export
 */
export const CapabilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets information about the server\'s supported feature set and other relevant capabilities.
         * @summary Gets information about the server\'s capabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCapabilities(options?: any): AxiosPromise<InlineResponse2006> {
            return CapabilitiesApiFp(configuration).getCapabilities(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CapabilitiesApi - object-oriented interface
 * @export
 * @class CapabilitiesApi
 * @extends {BaseAPI}
 */
export class CapabilitiesApi extends BaseAPI {
    /**
     * Gets information about the server\'s supported feature set and other relevant capabilities.
     * @summary Gets information about the server\'s capabilities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public getCapabilities(options?: any) {
        return CapabilitiesApiFp(this.configuration).getCapabilities(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DeviceManagementApi - axios parameter creator
 * @export
 */
export const DeviceManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given device, and invalidates any access token associated with it.
         * @summary Delete a device
         * @param {string} deviceId The device to delete.
         * @param {InlineObject9} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (deviceId: string, body?: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling deleteDevice.');
            }
            const localVarPath = `/_matrix/client/r0/devices/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given devices, and invalidates any access token associated with them.
         * @summary Bulk deletion of devices
         * @param {InlineObject7} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevices: async (body?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/delete_devices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information on a single device, by device id.
         * @summary Get a single device
         * @param {string} deviceId The device to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getDevice.');
            }
            const localVarPath = `/_matrix/client/r0/devices/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information about all devices for the current user.
         * @summary List registered devices for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/devices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the metadata on the given device.
         * @summary Update a device
         * @param {string} deviceId The device to update.
         * @param {InlineObject8} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (deviceId: string, body: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling updateDevice.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDevice.');
            }
            const localVarPath = `/_matrix/client/r0/devices/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceManagementApi - functional programming interface
 * @export
 */
export const DeviceManagementApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given device, and invalidates any access token associated with it.
         * @summary Delete a device
         * @param {string} deviceId The device to delete.
         * @param {InlineObject9} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(deviceId: string, body?: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DeviceManagementApiAxiosParamCreator(configuration).deleteDevice(deviceId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given devices, and invalidates any access token associated with them.
         * @summary Bulk deletion of devices
         * @param {InlineObject7} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevices(body?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DeviceManagementApiAxiosParamCreator(configuration).deleteDevices(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets information on a single device, by device id.
         * @summary Get a single device
         * @param {string} deviceId The device to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await DeviceManagementApiAxiosParamCreator(configuration).getDevice(deviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets information about all devices for the current user.
         * @summary List registered devices for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await DeviceManagementApiAxiosParamCreator(configuration).getDevices(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the metadata on the given device.
         * @summary Update a device
         * @param {string} deviceId The device to update.
         * @param {InlineObject8} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(deviceId: string, body: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DeviceManagementApiAxiosParamCreator(configuration).updateDevice(deviceId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceManagementApi - factory interface
 * @export
 */
export const DeviceManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given device, and invalidates any access token associated with it.
         * @summary Delete a device
         * @param {string} deviceId The device to delete.
         * @param {InlineObject9} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(deviceId: string, body?: InlineObject9, options?: any): AxiosPromise<object> {
            return DeviceManagementApiFp(configuration).deleteDevice(deviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given devices, and invalidates any access token associated with them.
         * @summary Bulk deletion of devices
         * @param {InlineObject7} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevices(body?: InlineObject7, options?: any): AxiosPromise<object> {
            return DeviceManagementApiFp(configuration).deleteDevices(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information on a single device, by device id.
         * @summary Get a single device
         * @param {string} deviceId The device to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(deviceId: string, options?: any): AxiosPromise<InlineResponse2009> {
            return DeviceManagementApiFp(configuration).getDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information about all devices for the current user.
         * @summary List registered devices for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(options?: any): AxiosPromise<InlineResponse2008> {
            return DeviceManagementApiFp(configuration).getDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the metadata on the given device.
         * @summary Update a device
         * @param {string} deviceId The device to update.
         * @param {InlineObject8} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(deviceId: string, body: InlineObject8, options?: any): AxiosPromise<object> {
            return DeviceManagementApiFp(configuration).updateDevice(deviceId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceManagementApi - object-oriented interface
 * @export
 * @class DeviceManagementApi
 * @extends {BaseAPI}
 */
export class DeviceManagementApi extends BaseAPI {
    /**
     * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given device, and invalidates any access token associated with it.
     * @summary Delete a device
     * @param {string} deviceId The device to delete.
     * @param {InlineObject9} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceManagementApi
     */
    public deleteDevice(deviceId: string, body?: InlineObject9, options?: any) {
        return DeviceManagementApiFp(this.configuration).deleteDevice(deviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint uses the `User-Interactive Authentication API`_.  Deletes the given devices, and invalidates any access token associated with them.
     * @summary Bulk deletion of devices
     * @param {InlineObject7} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceManagementApi
     */
    public deleteDevices(body?: InlineObject7, options?: any) {
        return DeviceManagementApiFp(this.configuration).deleteDevices(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information on a single device, by device id.
     * @summary Get a single device
     * @param {string} deviceId The device to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceManagementApi
     */
    public getDevice(deviceId: string, options?: any) {
        return DeviceManagementApiFp(this.configuration).getDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information about all devices for the current user.
     * @summary List registered devices for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceManagementApi
     */
    public getDevices(options?: any) {
        return DeviceManagementApiFp(this.configuration).getDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the metadata on the given device.
     * @summary Update a device
     * @param {string} deviceId The device to update.
     * @param {InlineObject8} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceManagementApi
     */
    public updateDevice(deviceId: string, body: InlineObject8, options?: any) {
        return DeviceManagementApiFp(this.configuration).updateDevice(deviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EndToEndEncryptionApi - axios parameter creator
 * @export
 */
export const EndToEndEncryptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Claims one-time keys for use in pre-key messages.
         * @summary Claim one-time encryption keys.
         * @param {InlineObject13} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimKeys: async (query?: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/keys/claim`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof query !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(query !== undefined ? query : {}) : (query || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of users who have updated their device identity keys since a previous sync token.  The server should include in the results any users who:  * currently share a room with the calling user (ie, both users have   membership state ``join``); *and* * added new device identity keys or removed an existing device with   identity keys, between ``from`` and ``to``.
         * @summary Query users with recent device key updates.
         * @param {string} from The desired start point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a response to an earlier call to |/sync|. Users who have not uploaded new device identity keys since this point, nor deleted existing devices with identity keys since then, will be excluded from the results.
         * @param {string} to The desired end point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a recent call to |/sync| - typically the most recent such call. This may be used by the server as a hint to check its caches are up to date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeysChanges: async (from: string, to: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getKeysChanges.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling getKeysChanges.');
            }
            const localVarPath = `/_matrix/client/r0/keys/changes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current devices and identity keys for the given users.
         * @summary Download device identity keys.
         * @param {InlineObject14} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryKeys: async (query?: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/keys/query`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof query !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(query !== undefined ? query : {}) : (query || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publishes end-to-end encryption keys for the device.
         * @summary Upload end-to-end encryption keys.
         * @param {InlineObject15} [keys]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKeys: async (keys?: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/keys/upload`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof keys !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(keys !== undefined ? keys : {}) : (keys || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndToEndEncryptionApi - functional programming interface
 * @export
 */
export const EndToEndEncryptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Claims one-time keys for use in pre-key messages.
         * @summary Claim one-time encryption keys.
         * @param {InlineObject13} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimKeys(query?: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await EndToEndEncryptionApiAxiosParamCreator(configuration).claimKeys(query, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of users who have updated their device identity keys since a previous sync token.  The server should include in the results any users who:  * currently share a room with the calling user (ie, both users have   membership state ``join``); *and* * added new device identity keys or removed an existing device with   identity keys, between ``from`` and ``to``.
         * @summary Query users with recent device key updates.
         * @param {string} from The desired start point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a response to an earlier call to |/sync|. Users who have not uploaded new device identity keys since this point, nor deleted existing devices with identity keys since then, will be excluded from the results.
         * @param {string} to The desired end point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a recent call to |/sync| - typically the most recent such call. This may be used by the server as a hint to check its caches are up to date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeysChanges(from: string, to: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await EndToEndEncryptionApiAxiosParamCreator(configuration).getKeysChanges(from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the current devices and identity keys for the given users.
         * @summary Download device identity keys.
         * @param {InlineObject14} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryKeys(query?: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await EndToEndEncryptionApiAxiosParamCreator(configuration).queryKeys(query, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Publishes end-to-end encryption keys for the device.
         * @summary Upload end-to-end encryption keys.
         * @param {InlineObject15} [keys]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKeys(keys?: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await EndToEndEncryptionApiAxiosParamCreator(configuration).uploadKeys(keys, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EndToEndEncryptionApi - factory interface
 * @export
 */
export const EndToEndEncryptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Claims one-time keys for use in pre-key messages.
         * @summary Claim one-time encryption keys.
         * @param {InlineObject13} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimKeys(query?: InlineObject13, options?: any): AxiosPromise<InlineResponse20017> {
            return EndToEndEncryptionApiFp(configuration).claimKeys(query, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of users who have updated their device identity keys since a previous sync token.  The server should include in the results any users who:  * currently share a room with the calling user (ie, both users have   membership state ``join``); *and* * added new device identity keys or removed an existing device with   identity keys, between ``from`` and ``to``.
         * @summary Query users with recent device key updates.
         * @param {string} from The desired start point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a response to an earlier call to |/sync|. Users who have not uploaded new device identity keys since this point, nor deleted existing devices with identity keys since then, will be excluded from the results.
         * @param {string} to The desired end point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a recent call to |/sync| - typically the most recent such call. This may be used by the server as a hint to check its caches are up to date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeysChanges(from: string, to: string, options?: any): AxiosPromise<InlineResponse20016> {
            return EndToEndEncryptionApiFp(configuration).getKeysChanges(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current devices and identity keys for the given users.
         * @summary Download device identity keys.
         * @param {InlineObject14} [query]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryKeys(query?: InlineObject14, options?: any): AxiosPromise<InlineResponse20018> {
            return EndToEndEncryptionApiFp(configuration).queryKeys(query, options).then((request) => request(axios, basePath));
        },
        /**
         * Publishes end-to-end encryption keys for the device.
         * @summary Upload end-to-end encryption keys.
         * @param {InlineObject15} [keys]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKeys(keys?: InlineObject15, options?: any): AxiosPromise<InlineResponse20019> {
            return EndToEndEncryptionApiFp(configuration).uploadKeys(keys, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndToEndEncryptionApi - object-oriented interface
 * @export
 * @class EndToEndEncryptionApi
 * @extends {BaseAPI}
 */
export class EndToEndEncryptionApi extends BaseAPI {
    /**
     * Claims one-time keys for use in pre-key messages.
     * @summary Claim one-time encryption keys.
     * @param {InlineObject13} [query]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndToEndEncryptionApi
     */
    public claimKeys(query?: InlineObject13, options?: any) {
        return EndToEndEncryptionApiFp(this.configuration).claimKeys(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of users who have updated their device identity keys since a previous sync token.  The server should include in the results any users who:  * currently share a room with the calling user (ie, both users have   membership state ``join``); *and* * added new device identity keys or removed an existing device with   identity keys, between ``from`` and ``to``.
     * @summary Query users with recent device key updates.
     * @param {string} from The desired start point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a response to an earlier call to |/sync|. Users who have not uploaded new device identity keys since this point, nor deleted existing devices with identity keys since then, will be excluded from the results.
     * @param {string} to The desired end point of the list. Should be the &#x60;&#x60;next_batch&#x60;&#x60; field from a recent call to |/sync| - typically the most recent such call. This may be used by the server as a hint to check its caches are up to date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndToEndEncryptionApi
     */
    public getKeysChanges(from: string, to: string, options?: any) {
        return EndToEndEncryptionApiFp(this.configuration).getKeysChanges(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current devices and identity keys for the given users.
     * @summary Download device identity keys.
     * @param {InlineObject14} [query]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndToEndEncryptionApi
     */
    public queryKeys(query?: InlineObject14, options?: any) {
        return EndToEndEncryptionApiFp(this.configuration).queryKeys(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publishes end-to-end encryption keys for the device.
     * @summary Upload end-to-end encryption keys.
     * @param {InlineObject15} [keys]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndToEndEncryptionApi
     */
    public uploadKeys(keys?: InlineObject15, options?: any) {
        return EndToEndEncryptionApiFp(this.configuration).uploadKeys(keys, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows clients to retrieve the configuration of the content repository, such as upload limitations. Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available.  **NOTE:** Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint.
         * @summary Get the configuration for the content repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/media/r0/config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Download content from the content repository.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent: async (serverName: string, mediaId: string, allowRemote?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverName' is not null or undefined
            if (serverName === null || serverName === undefined) {
                throw new RequiredError('serverName','Required parameter serverName was null or undefined when calling getContent.');
            }
            // verify required parameter 'mediaId' is not null or undefined
            if (mediaId === null || mediaId === undefined) {
                throw new RequiredError('mediaId','Required parameter mediaId was null or undefined when calling getContent.');
            }
            const localVarPath = `/_matrix/media/r0/download/{serverName}/{mediaId}`
                .replace(`{${"serverName"}}`, encodeURIComponent(String(serverName)))
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (allowRemote !== undefined) {
                localVarQueryParameter['allow_remote'] = allowRemote;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Download content from the content repository. This is the same as the download endpoint above, except permitting a desired file name.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {string} fileName A filename to give in the &#x60;&#x60;Content-Disposition&#x60;&#x60; header.
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentOverrideName: async (serverName: string, mediaId: string, fileName: string, allowRemote?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverName' is not null or undefined
            if (serverName === null || serverName === undefined) {
                throw new RequiredError('serverName','Required parameter serverName was null or undefined when calling getContentOverrideName.');
            }
            // verify required parameter 'mediaId' is not null or undefined
            if (mediaId === null || mediaId === undefined) {
                throw new RequiredError('mediaId','Required parameter mediaId was null or undefined when calling getContentOverrideName.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getContentOverrideName.');
            }
            const localVarPath = `/_matrix/media/r0/download/{serverName}/{mediaId}/{fileName}`
                .replace(`{${"serverName"}}`, encodeURIComponent(String(serverName)))
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (allowRemote !== undefined) {
                localVarQueryParameter['allow_remote'] = allowRemote;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Download a thumbnail of content from the content repository. See the `thumbnailing <#thumbnails>`_ section for more information.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {number} width The *desired* width of the thumbnail. The actual thumbnail may be larger than the size specified.
         * @param {number} height The *desired* height of the thumbnail. The actual thumbnail may be larger than the size specified.
         * @param {'crop' | 'scale'} [method] The desired resizing method. See the &#x60;thumbnailing &lt;#thumbnails&gt;&#x60;_ section for more information.
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentThumbnail: async (serverName: string, mediaId: string, width: number, height: number, method?: 'crop' | 'scale', allowRemote?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverName' is not null or undefined
            if (serverName === null || serverName === undefined) {
                throw new RequiredError('serverName','Required parameter serverName was null or undefined when calling getContentThumbnail.');
            }
            // verify required parameter 'mediaId' is not null or undefined
            if (mediaId === null || mediaId === undefined) {
                throw new RequiredError('mediaId','Required parameter mediaId was null or undefined when calling getContentThumbnail.');
            }
            // verify required parameter 'width' is not null or undefined
            if (width === null || width === undefined) {
                throw new RequiredError('width','Required parameter width was null or undefined when calling getContentThumbnail.');
            }
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getContentThumbnail.');
            }
            const localVarPath = `/_matrix/media/r0/thumbnail/{serverName}/{mediaId}`
                .replace(`{${"serverName"}}`, encodeURIComponent(String(serverName)))
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (allowRemote !== undefined) {
                localVarQueryParameter['allow_remote'] = allowRemote;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a URL for the client. Typically this is called when a client sees a URL in a message and wants to render a preview for the user.  .. Note::   Clients should consider avoiding this endpoint for URLs posted in encrypted   rooms. Encrypted rooms often contain more sensitive information the users   do not want to share with the homeserver, and this can mean that the URLs   being shared should also not be shared with the homeserver.
         * @summary Get information about a URL for a client
         * @param {string} url The URL to get a preview of.
         * @param {number} [ts] The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlPreview: async (url: string, ts?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling getUrlPreview.');
            }
            const localVarPath = `/_matrix/media/r0/preview_url`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload some content to the content repository.
         * @param {string} content The content to be uploaded.
         * @param {string} [contentType] The content type of the file being uploaded
         * @param {string} [filename] The name of the file being uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadContent: async (content: string, contentType?: string, filename?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling uploadContent.');
            }
            const localVarPath = `/_matrix/media/r0/upload`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof content !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(content !== undefined ? content : {}) : (content || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint allows clients to retrieve the configuration of the content repository, such as upload limitations. Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available.  **NOTE:** Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint.
         * @summary Get the configuration for the content repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20052>> {
            const localVarAxiosArgs = await MediaApiAxiosParamCreator(configuration).getConfig(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Download content from the content repository.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContent(serverName: string, mediaId: string, allowRemote?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await MediaApiAxiosParamCreator(configuration).getContent(serverName, mediaId, allowRemote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Download content from the content repository. This is the same as the download endpoint above, except permitting a desired file name.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {string} fileName A filename to give in the &#x60;&#x60;Content-Disposition&#x60;&#x60; header.
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentOverrideName(serverName: string, mediaId: string, fileName: string, allowRemote?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await MediaApiAxiosParamCreator(configuration).getContentOverrideName(serverName, mediaId, fileName, allowRemote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Download a thumbnail of content from the content repository. See the `thumbnailing <#thumbnails>`_ section for more information.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {number} width The *desired* width of the thumbnail. The actual thumbnail may be larger than the size specified.
         * @param {number} height The *desired* height of the thumbnail. The actual thumbnail may be larger than the size specified.
         * @param {'crop' | 'scale'} [method] The desired resizing method. See the &#x60;thumbnailing &lt;#thumbnails&gt;&#x60;_ section for more information.
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentThumbnail(serverName: string, mediaId: string, width: number, height: number, method?: 'crop' | 'scale', allowRemote?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await MediaApiAxiosParamCreator(configuration).getContentThumbnail(serverName, mediaId, width, height, method, allowRemote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information about a URL for the client. Typically this is called when a client sees a URL in a message and wants to render a preview for the user.  .. Note::   Clients should consider avoiding this endpoint for URLs posted in encrypted   rooms. Encrypted rooms often contain more sensitive information the users   do not want to share with the homeserver, and this can mean that the URLs   being shared should also not be shared with the homeserver.
         * @summary Get information about a URL for a client
         * @param {string} url The URL to get a preview of.
         * @param {number} [ts] The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrlPreview(url: string, ts?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20053>> {
            const localVarAxiosArgs = await MediaApiAxiosParamCreator(configuration).getUrlPreview(url, ts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Upload some content to the content repository.
         * @param {string} content The content to be uploaded.
         * @param {string} [contentType] The content type of the file being uploaded
         * @param {string} [filename] The name of the file being uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadContent(content: string, contentType?: string, filename?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20054>> {
            const localVarAxiosArgs = await MediaApiAxiosParamCreator(configuration).uploadContent(content, contentType, filename, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint allows clients to retrieve the configuration of the content repository, such as upload limitations. Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available.  **NOTE:** Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint.
         * @summary Get the configuration for the content repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<InlineResponse20052> {
            return MediaApiFp(configuration).getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Download content from the content repository.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent(serverName: string, mediaId: string, allowRemote?: boolean, options?: any): AxiosPromise<any> {
            return MediaApiFp(configuration).getContent(serverName, mediaId, allowRemote, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Download content from the content repository. This is the same as the download endpoint above, except permitting a desired file name.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {string} fileName A filename to give in the &#x60;&#x60;Content-Disposition&#x60;&#x60; header.
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentOverrideName(serverName: string, mediaId: string, fileName: string, allowRemote?: boolean, options?: any): AxiosPromise<any> {
            return MediaApiFp(configuration).getContentOverrideName(serverName, mediaId, fileName, allowRemote, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Download a thumbnail of content from the content repository. See the `thumbnailing <#thumbnails>`_ section for more information.
         * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
         * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
         * @param {number} width The *desired* width of the thumbnail. The actual thumbnail may be larger than the size specified.
         * @param {number} height The *desired* height of the thumbnail. The actual thumbnail may be larger than the size specified.
         * @param {'crop' | 'scale'} [method] The desired resizing method. See the &#x60;thumbnailing &lt;#thumbnails&gt;&#x60;_ section for more information.
         * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentThumbnail(serverName: string, mediaId: string, width: number, height: number, method?: 'crop' | 'scale', allowRemote?: boolean, options?: any): AxiosPromise<any> {
            return MediaApiFp(configuration).getContentThumbnail(serverName, mediaId, width, height, method, allowRemote, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a URL for the client. Typically this is called when a client sees a URL in a message and wants to render a preview for the user.  .. Note::   Clients should consider avoiding this endpoint for URLs posted in encrypted   rooms. Encrypted rooms often contain more sensitive information the users   do not want to share with the homeserver, and this can mean that the URLs   being shared should also not be shared with the homeserver.
         * @summary Get information about a URL for a client
         * @param {string} url The URL to get a preview of.
         * @param {number} [ts] The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlPreview(url: string, ts?: number, options?: any): AxiosPromise<InlineResponse20053> {
            return MediaApiFp(configuration).getUrlPreview(url, ts, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload some content to the content repository.
         * @param {string} content The content to be uploaded.
         * @param {string} [contentType] The content type of the file being uploaded
         * @param {string} [filename] The name of the file being uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadContent(content: string, contentType?: string, filename?: string, options?: any): AxiosPromise<InlineResponse20054> {
            return MediaApiFp(configuration).uploadContent(content, contentType, filename, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * This endpoint allows clients to retrieve the configuration of the content repository, such as upload limitations. Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available.  **NOTE:** Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint.
     * @summary Get the configuration for the content repository.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getConfig(options?: any) {
        return MediaApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Download content from the content repository.
     * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
     * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
     * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getContent(serverName: string, mediaId: string, allowRemote?: boolean, options?: any) {
        return MediaApiFp(this.configuration).getContent(serverName, mediaId, allowRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Download content from the content repository. This is the same as the download endpoint above, except permitting a desired file name.
     * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
     * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
     * @param {string} fileName A filename to give in the &#x60;&#x60;Content-Disposition&#x60;&#x60; header.
     * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getContentOverrideName(serverName: string, mediaId: string, fileName: string, allowRemote?: boolean, options?: any) {
        return MediaApiFp(this.configuration).getContentOverrideName(serverName, mediaId, fileName, allowRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Download a thumbnail of content from the content repository. See the `thumbnailing <#thumbnails>`_ section for more information.
     * @param {string} serverName The server name from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the authoritory component)
     * @param {string} mediaId The media ID from the &#x60;&#x60;mxc://&#x60;&#x60; URI (the path component)
     * @param {number} width The *desired* width of the thumbnail. The actual thumbnail may be larger than the size specified.
     * @param {number} height The *desired* height of the thumbnail. The actual thumbnail may be larger than the size specified.
     * @param {'crop' | 'scale'} [method] The desired resizing method. See the &#x60;thumbnailing &lt;#thumbnails&gt;&#x60;_ section for more information.
     * @param {boolean} [allowRemote] Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getContentThumbnail(serverName: string, mediaId: string, width: number, height: number, method?: 'crop' | 'scale', allowRemote?: boolean, options?: any) {
        return MediaApiFp(this.configuration).getContentThumbnail(serverName, mediaId, width, height, method, allowRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a URL for the client. Typically this is called when a client sees a URL in a message and wants to render a preview for the user.  .. Note::   Clients should consider avoiding this endpoint for URLs posted in encrypted   rooms. Encrypted rooms often contain more sensitive information the users   do not want to share with the homeserver, and this can mean that the URLs   being shared should also not be shared with the homeserver.
     * @summary Get information about a URL for a client
     * @param {string} url The URL to get a preview of.
     * @param {number} [ts] The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getUrlPreview(url: string, ts?: number, options?: any) {
        return MediaApiFp(this.configuration).getUrlPreview(url, ts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Upload some content to the content repository.
     * @param {string} content The content to be uploaded.
     * @param {string} [contentType] The content type of the file being uploaded
     * @param {string} [filename] The name of the file being uploaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public uploadContent(content: string, contentType?: string, filename?: string, options?: any) {
        return MediaApiFp(this.configuration).uploadContent(content, contentType, filename, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OpenIDApi - axios parameter creator
 * @export
 */
export const OpenIDApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets an OpenID token object that the requester may supply to another service to verify their identity in Matrix. The generated token is only valid for exchanging for user information from the federation API for OpenID.  The access token generated is only valid for the OpenID API. It cannot be used to request another OpenID access token or call ``/sync``, for example.
         * @summary Get an OpenID token object to verify the requester\'s identity.
         * @param {string} userId The user to request and OpenID token for. Should be the user who is authenticated for the request.
         * @param {object} body An empty object. Reserved for future expansion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOpenIdToken: async (userId: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling requestOpenIdToken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling requestOpenIdToken.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/openid/request_token`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenIDApi - functional programming interface
 * @export
 */
export const OpenIDApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets an OpenID token object that the requester may supply to another service to verify their identity in Matrix. The generated token is only valid for exchanging for user information from the federation API for OpenID.  The access token generated is only valid for the OpenID API. It cannot be used to request another OpenID access token or call ``/sync``, for example.
         * @summary Get an OpenID token object to verify the requester\'s identity.
         * @param {string} userId The user to request and OpenID token for. Should be the user who is authenticated for the request.
         * @param {object} body An empty object. Reserved for future expansion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestOpenIdToken(userId: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await OpenIDApiAxiosParamCreator(configuration).requestOpenIdToken(userId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OpenIDApi - factory interface
 * @export
 */
export const OpenIDApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets an OpenID token object that the requester may supply to another service to verify their identity in Matrix. The generated token is only valid for exchanging for user information from the federation API for OpenID.  The access token generated is only valid for the OpenID API. It cannot be used to request another OpenID access token or call ``/sync``, for example.
         * @summary Get an OpenID token object to verify the requester\'s identity.
         * @param {string} userId The user to request and OpenID token for. Should be the user who is authenticated for the request.
         * @param {object} body An empty object. Reserved for future expansion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOpenIdToken(userId: string, body: object, options?: any): AxiosPromise<InlineResponse20047> {
            return OpenIDApiFp(configuration).requestOpenIdToken(userId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenIDApi - object-oriented interface
 * @export
 * @class OpenIDApi
 * @extends {BaseAPI}
 */
export class OpenIDApi extends BaseAPI {
    /**
     * Gets an OpenID token object that the requester may supply to another service to verify their identity in Matrix. The generated token is only valid for exchanging for user information from the federation API for OpenID.  The access token generated is only valid for the OpenID API. It cannot be used to request another OpenID access token or call ``/sync``, for example.
     * @summary Get an OpenID token object to verify the requester\'s identity.
     * @param {string} userId The user to request and OpenID token for. Should be the user who is authenticated for the request.
     * @param {object} body An empty object. Reserved for future expansion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDApi
     */
    public requestOpenIdToken(userId: string, body: object, options?: any) {
        return OpenIDApiFp(this.configuration).requestOpenIdToken(userId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PresenceApi - axios parameter creator
 * @export
 */
export const PresenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the given user\'s presence state.
         * @summary Get this user\'s presence state.
         * @param {string} userId The user whose presence state to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresence: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getPresence.');
            }
            const localVarPath = `/_matrix/client/r0/presence/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API sets the given user\'s presence state. When setting the status, the activity time is updated to reflect that activity; the client does not need to specify the ``last_active_ago`` field. You cannot set the presence state of another user.
         * @summary Update this user\'s presence state.
         * @param {string} userId The user whose presence state to update.
         * @param {InlineObject17} presenceState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPresence: async (userId: string, presenceState: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setPresence.');
            }
            // verify required parameter 'presenceState' is not null or undefined
            if (presenceState === null || presenceState === undefined) {
                throw new RequiredError('presenceState','Required parameter presenceState was null or undefined when calling setPresence.');
            }
            const localVarPath = `/_matrix/client/r0/presence/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof presenceState !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(presenceState !== undefined ? presenceState : {}) : (presenceState || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PresenceApi - functional programming interface
 * @export
 */
export const PresenceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the given user\'s presence state.
         * @summary Get this user\'s presence state.
         * @param {string} userId The user whose presence state to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresence(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await PresenceApiAxiosParamCreator(configuration).getPresence(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API sets the given user\'s presence state. When setting the status, the activity time is updated to reflect that activity; the client does not need to specify the ``last_active_ago`` field. You cannot set the presence state of another user.
         * @summary Update this user\'s presence state.
         * @param {string} userId The user whose presence state to update.
         * @param {InlineObject17} presenceState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPresence(userId: string, presenceState: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PresenceApiAxiosParamCreator(configuration).setPresence(userId, presenceState, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PresenceApi - factory interface
 * @export
 */
export const PresenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the given user\'s presence state.
         * @summary Get this user\'s presence state.
         * @param {string} userId The user whose presence state to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresence(userId: string, options?: any): AxiosPromise<InlineResponse20023> {
            return PresenceApiFp(configuration).getPresence(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the given user\'s presence state. When setting the status, the activity time is updated to reflect that activity; the client does not need to specify the ``last_active_ago`` field. You cannot set the presence state of another user.
         * @summary Update this user\'s presence state.
         * @param {string} userId The user whose presence state to update.
         * @param {InlineObject17} presenceState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPresence(userId: string, presenceState: InlineObject17, options?: any): AxiosPromise<object> {
            return PresenceApiFp(configuration).setPresence(userId, presenceState, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PresenceApi - object-oriented interface
 * @export
 * @class PresenceApi
 * @extends {BaseAPI}
 */
export class PresenceApi extends BaseAPI {
    /**
     * Get the given user\'s presence state.
     * @summary Get this user\'s presence state.
     * @param {string} userId The user whose presence state to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresenceApi
     */
    public getPresence(userId: string, options?: any) {
        return PresenceApiFp(this.configuration).getPresence(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the given user\'s presence state. When setting the status, the activity time is updated to reflect that activity; the client does not need to specify the ``last_active_ago`` field. You cannot set the presence state of another user.
     * @summary Update this user\'s presence state.
     * @param {string} userId The user whose presence state to update.
     * @param {InlineObject17} presenceState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresenceApi
     */
    public setPresence(userId: string, presenceState: InlineObject17, options?: any) {
        return PresenceApiFp(this.configuration).setPresence(userId, presenceState, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PushNotificationsApi - axios parameter creator
 * @export
 */
export const PushNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint removes the push rule defined in the path.
         * @summary Delete a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushRule: async (scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling deletePushRule.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling deletePushRule.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling deletePushRule.');
            }
            const localVarPath = `/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used to paginate through the list of events that the user has been, or would have been notified about.
         * @summary Gets a list of events that the user has been notified about
         * @param {string} [from] Pagination token given to retrieve the next set of events.
         * @param {number} [limit] Limit on the number of events to return in this request.
         * @param {string} [only] Allows basic filtering of events returned. Supply &#x60;&#x60;highlight&#x60;&#x60; to return only events where the notification had the highlight tweak set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (from?: string, limit?: number, only?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/notifications`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (only !== undefined) {
                localVarQueryParameter['only'] = only;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single specified push rule.
         * @summary Retrieve a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushRule: async (scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling getPushRule.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling getPushRule.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling getPushRule.');
            }
            const localVarPath = `/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint get the actions for the specified push rule.
         * @summary The actions for a push rule
         * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushRuleActions: async (scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling getPushRuleActions.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling getPushRuleActions.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling getPushRuleActions.');
            }
            const localVarPath = `/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/actions`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all push rulesets for this user. Clients can \"drill-down\" on the rulesets by suffixing a ``scope`` to this path e.g. ``/pushrules/global/``. This will return a subset of this data under the specified key e.g. the ``global`` key.
         * @summary Retrieve all push rulesets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushRules: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/pushrules/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all currently active pushers for the authenticated user.
         * @summary Gets the current pushers for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/pushers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets whether the specified push rule is enabled.
         * @summary Get whether a push rule is enabled
         * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isPushRuleEnabled: async (scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling isPushRuleEnabled.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling isPushRuleEnabled.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling isPushRuleEnabled.');
            }
            const localVarPath = `/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/enabled`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the creation, modification and deletion of `pushers`_ for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.
         * @summary Modify a pusher for this user on the homeserver.
         * @param {InlineObject21} pusher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPusher: async (pusher: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pusher' is not null or undefined
            if (pusher === null || pusher === undefined) {
                throw new RequiredError('pusher','Required parameter pusher was null or undefined when calling postPusher.');
            }
            const localVarPath = `/_matrix/client/r0/pushers/set`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pusher !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pusher !== undefined ? pusher : {}) : (pusher || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.  When creating push rules, they MUST be enabled by default.
         * @summary Add or change a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject22} pushrule
         * @param {string} [before] Use \&#39;before\&#39; with a &#x60;&#x60;rule_id&#x60;&#x60; as its value to make the new rule the next-most important rule with respect to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
         * @param {string} [after] This makes the new rule the next-less important rule relative to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPushRule: async (scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, pushrule: InlineObject22, before?: string, after?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling setPushRule.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling setPushRule.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling setPushRule.');
            }
            // verify required parameter 'pushrule' is not null or undefined
            if (pushrule === null || pushrule === undefined) {
                throw new RequiredError('pushrule','Required parameter pushrule was null or undefined when calling setPushRule.');
            }
            const localVarPath = `/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pushrule !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pushrule !== undefined ? pushrule : {}) : (pushrule || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows clients to change the actions of a push rule. This can be used to change the actions of builtin rules.
         * @summary Set the actions for a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject23} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPushRuleActions: async (scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling setPushRuleActions.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling setPushRuleActions.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling setPushRuleActions.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setPushRuleActions.');
            }
            const localVarPath = `/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/actions`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows clients to enable or disable the specified push rule.
         * @summary Enable or disable a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject24} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPushRuleEnabled: async (scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling setPushRuleEnabled.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling setPushRuleEnabled.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling setPushRuleEnabled.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setPushRuleEnabled.');
            }
            const localVarPath = `/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/enabled`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushNotificationsApi - functional programming interface
 * @export
 */
export const PushNotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint removes the push rule defined in the path.
         * @summary Delete a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).deletePushRule(scope, kind, ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API is used to paginate through the list of events that the user has been, or would have been notified about.
         * @summary Gets a list of events that the user has been notified about
         * @param {string} [from] Pagination token given to retrieve the next set of events.
         * @param {number} [limit] Limit on the number of events to return in this request.
         * @param {string} [only] Allows basic filtering of events returned. Supply &#x60;&#x60;highlight&#x60;&#x60; to return only events where the notification had the highlight tweak set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(from?: string, limit?: number, only?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).getNotifications(from, limit, only, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a single specified push rule.
         * @summary Retrieve a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).getPushRule(scope, kind, ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint get the actions for the specified push rule.
         * @summary The actions for a push rule
         * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushRuleActions(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).getPushRuleActions(scope, kind, ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all push rulesets for this user. Clients can \"drill-down\" on the rulesets by suffixing a ``scope`` to this path e.g. ``/pushrules/global/``. This will return a subset of this data under the specified key e.g. the ``global`` key.
         * @summary Retrieve all push rulesets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushRules(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).getPushRules(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all currently active pushers for the authenticated user.
         * @summary Gets the current pushers for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).getPushers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint gets whether the specified push rule is enabled.
         * @summary Get whether a push rule is enabled
         * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isPushRuleEnabled(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).isPushRuleEnabled(scope, kind, ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows the creation, modification and deletion of `pushers`_ for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.
         * @summary Modify a pusher for this user on the homeserver.
         * @param {InlineObject21} pusher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPusher(pusher: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).postPusher(pusher, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.  When creating push rules, they MUST be enabled by default.
         * @summary Add or change a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject22} pushrule
         * @param {string} [before] Use \&#39;before\&#39; with a &#x60;&#x60;rule_id&#x60;&#x60; as its value to make the new rule the next-most important rule with respect to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
         * @param {string} [after] This makes the new rule the next-less important rule relative to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, pushrule: InlineObject22, before?: string, after?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).setPushRule(scope, kind, ruleId, pushrule, before, after, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows clients to change the actions of a push rule. This can be used to change the actions of builtin rules.
         * @summary Set the actions for a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject23} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPushRuleActions(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).setPushRuleActions(scope, kind, ruleId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows clients to enable or disable the specified push rule.
         * @summary Enable or disable a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject24} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPushRuleEnabled(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PushNotificationsApiAxiosParamCreator(configuration).setPushRuleEnabled(scope, kind, ruleId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PushNotificationsApi - factory interface
 * @export
 */
export const PushNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint removes the push rule defined in the path.
         * @summary Delete a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): AxiosPromise<object> {
            return PushNotificationsApiFp(configuration).deletePushRule(scope, kind, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to paginate through the list of events that the user has been, or would have been notified about.
         * @summary Gets a list of events that the user has been notified about
         * @param {string} [from] Pagination token given to retrieve the next set of events.
         * @param {number} [limit] Limit on the number of events to return in this request.
         * @param {string} [only] Allows basic filtering of events returned. Supply &#x60;&#x60;highlight&#x60;&#x60; to return only events where the notification had the highlight tweak set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(from?: string, limit?: number, only?: string, options?: any): AxiosPromise<InlineResponse20022> {
            return PushNotificationsApiFp(configuration).getNotifications(from, limit, only, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single specified push rule.
         * @summary Retrieve a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): AxiosPromise<InlineResponse20031> {
            return PushNotificationsApiFp(configuration).getPushRule(scope, kind, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint get the actions for the specified push rule.
         * @summary The actions for a push rule
         * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushRuleActions(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): AxiosPromise<InlineResponse20032> {
            return PushNotificationsApiFp(configuration).getPushRuleActions(scope, kind, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all push rulesets for this user. Clients can \"drill-down\" on the rulesets by suffixing a ``scope`` to this path e.g. ``/pushrules/global/``. This will return a subset of this data under the specified key e.g. the ``global`` key.
         * @summary Retrieve all push rulesets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushRules(options?: any): AxiosPromise<InlineResponse20030> {
            return PushNotificationsApiFp(configuration).getPushRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all currently active pushers for the authenticated user.
         * @summary Gets the current pushers for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushers(options?: any): AxiosPromise<InlineResponse20029> {
            return PushNotificationsApiFp(configuration).getPushers(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets whether the specified push rule is enabled.
         * @summary Get whether a push rule is enabled
         * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isPushRuleEnabled(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any): AxiosPromise<InlineResponse20033> {
            return PushNotificationsApiFp(configuration).isPushRuleEnabled(scope, kind, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the creation, modification and deletion of `pushers`_ for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.
         * @summary Modify a pusher for this user on the homeserver.
         * @param {InlineObject21} pusher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPusher(pusher: InlineObject21, options?: any): AxiosPromise<object> {
            return PushNotificationsApiFp(configuration).postPusher(pusher, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.  When creating push rules, they MUST be enabled by default.
         * @summary Add or change a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject22} pushrule
         * @param {string} [before] Use \&#39;before\&#39; with a &#x60;&#x60;rule_id&#x60;&#x60; as its value to make the new rule the next-most important rule with respect to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
         * @param {string} [after] This makes the new rule the next-less important rule relative to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, pushrule: InlineObject22, before?: string, after?: string, options?: any): AxiosPromise<object> {
            return PushNotificationsApiFp(configuration).setPushRule(scope, kind, ruleId, pushrule, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows clients to change the actions of a push rule. This can be used to change the actions of builtin rules.
         * @summary Set the actions for a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject23} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPushRuleActions(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject23, options?: any): AxiosPromise<object> {
            return PushNotificationsApiFp(configuration).setPushRuleActions(scope, kind, ruleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows clients to enable or disable the specified push rule.
         * @summary Enable or disable a push rule.
         * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
         * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
         * @param {string} ruleId The identifier for the rule.
         * @param {InlineObject24} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPushRuleEnabled(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject24, options?: any): AxiosPromise<object> {
            return PushNotificationsApiFp(configuration).setPushRuleEnabled(scope, kind, ruleId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushNotificationsApi - object-oriented interface
 * @export
 * @class PushNotificationsApi
 * @extends {BaseAPI}
 */
export class PushNotificationsApi extends BaseAPI {
    /**
     * This endpoint removes the push rule defined in the path.
     * @summary Delete a push rule.
     * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
     * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
     * @param {string} ruleId The identifier for the rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public deletePushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any) {
        return PushNotificationsApiFp(this.configuration).deletePushRule(scope, kind, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to paginate through the list of events that the user has been, or would have been notified about.
     * @summary Gets a list of events that the user has been notified about
     * @param {string} [from] Pagination token given to retrieve the next set of events.
     * @param {number} [limit] Limit on the number of events to return in this request.
     * @param {string} [only] Allows basic filtering of events returned. Supply &#x60;&#x60;highlight&#x60;&#x60; to return only events where the notification had the highlight tweak set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public getNotifications(from?: string, limit?: number, only?: string, options?: any) {
        return PushNotificationsApiFp(this.configuration).getNotifications(from, limit, only, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single specified push rule.
     * @summary Retrieve a push rule.
     * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
     * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
     * @param {string} ruleId The identifier for the rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public getPushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any) {
        return PushNotificationsApiFp(this.configuration).getPushRule(scope, kind, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint get the actions for the specified push rule.
     * @summary The actions for a push rule
     * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
     * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
     * @param {string} ruleId The identifier for the rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public getPushRuleActions(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any) {
        return PushNotificationsApiFp(this.configuration).getPushRuleActions(scope, kind, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all push rulesets for this user. Clients can \"drill-down\" on the rulesets by suffixing a ``scope`` to this path e.g. ``/pushrules/global/``. This will return a subset of this data under the specified key e.g. the ``global`` key.
     * @summary Retrieve all push rulesets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public getPushRules(options?: any) {
        return PushNotificationsApiFp(this.configuration).getPushRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all currently active pushers for the authenticated user.
     * @summary Gets the current pushers for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public getPushers(options?: any) {
        return PushNotificationsApiFp(this.configuration).getPushers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets whether the specified push rule is enabled.
     * @summary Get whether a push rule is enabled
     * @param {string} scope Either &#x60;&#x60;global&#x60;&#x60; or &#x60;&#x60;device/&lt;profile_tag&gt;&#x60;&#x60; to specify global rules or device rules for the given &#x60;&#x60;profile_tag&#x60;&#x60;.
     * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
     * @param {string} ruleId The identifier for the rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public isPushRuleEnabled(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, options?: any) {
        return PushNotificationsApiFp(this.configuration).isPushRuleEnabled(scope, kind, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the creation, modification and deletion of `pushers`_ for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.
     * @summary Modify a pusher for this user on the homeserver.
     * @param {InlineObject21} pusher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public postPusher(pusher: InlineObject21, options?: any) {
        return PushNotificationsApiFp(this.configuration).postPusher(pusher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.  When creating push rules, they MUST be enabled by default.
     * @summary Add or change a push rule.
     * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
     * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
     * @param {string} ruleId The identifier for the rule.
     * @param {InlineObject22} pushrule
     * @param {string} [before] Use \&#39;before\&#39; with a &#x60;&#x60;rule_id&#x60;&#x60; as its value to make the new rule the next-most important rule with respect to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
     * @param {string} [after] This makes the new rule the next-less important rule relative to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public setPushRule(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, pushrule: InlineObject22, before?: string, after?: string, options?: any) {
        return PushNotificationsApiFp(this.configuration).setPushRule(scope, kind, ruleId, pushrule, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows clients to change the actions of a push rule. This can be used to change the actions of builtin rules.
     * @summary Set the actions for a push rule.
     * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
     * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
     * @param {string} ruleId The identifier for the rule.
     * @param {InlineObject23} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public setPushRuleActions(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject23, options?: any) {
        return PushNotificationsApiFp(this.configuration).setPushRuleActions(scope, kind, ruleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows clients to enable or disable the specified push rule.
     * @summary Enable or disable a push rule.
     * @param {string} scope &#x60;&#x60;global&#x60;&#x60; to specify global rules.
     * @param {'override' | 'underride' | 'sender' | 'room' | 'content'} kind The kind of rule
     * @param {string} ruleId The identifier for the rule.
     * @param {InlineObject24} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public setPushRuleEnabled(scope: string, kind: 'override' | 'underride' | 'sender' | 'room' | 'content', ruleId: string, body: InlineObject24, options?: any) {
        return PushNotificationsApiFp(this.configuration).setPushRuleEnabled(scope, kind, ruleId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ReadMarkersApi - axios parameter creator
 * @export
 */
export const ReadMarkersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sets the position of the read marker for a given room, and optionally the read receipt\'s location.
         * @summary Set the position of the read marker for a room.
         * @param {string} roomId The room ID to set the read marker in for the user.
         * @param {InlineObject31} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReadMarker: async (roomId: string, body: InlineObject31, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling setReadMarker.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setReadMarker.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/read_markers`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReadMarkersApi - functional programming interface
 * @export
 */
export const ReadMarkersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Sets the position of the read marker for a given room, and optionally the read receipt\'s location.
         * @summary Set the position of the read marker for a room.
         * @param {string} roomId The room ID to set the read marker in for the user.
         * @param {InlineObject31} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setReadMarker(roomId: string, body: InlineObject31, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await ReadMarkersApiAxiosParamCreator(configuration).setReadMarker(roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReadMarkersApi - factory interface
 * @export
 */
export const ReadMarkersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Sets the position of the read marker for a given room, and optionally the read receipt\'s location.
         * @summary Set the position of the read marker for a room.
         * @param {string} roomId The room ID to set the read marker in for the user.
         * @param {InlineObject31} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReadMarker(roomId: string, body: InlineObject31, options?: any): AxiosPromise<object> {
            return ReadMarkersApiFp(configuration).setReadMarker(roomId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReadMarkersApi - object-oriented interface
 * @export
 * @class ReadMarkersApi
 * @extends {BaseAPI}
 */
export class ReadMarkersApi extends BaseAPI {
    /**
     * Sets the position of the read marker for a given room, and optionally the read receipt\'s location.
     * @summary Set the position of the read marker for a room.
     * @param {string} roomId The room ID to set the read marker in for the user.
     * @param {InlineObject31} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadMarkersApi
     */
    public setReadMarker(roomId: string, body: InlineObject31, options?: any) {
        return ReadMarkersApiFp(this.configuration).setReadMarker(roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ReportingContentApi - axios parameter creator
 * @export
 */
export const ReportingContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reports an event as inappropriate to the server, which may then notify the appropriate people.
         * @summary Reports an event as inappropriate.
         * @param {string} roomId The room in which the event being reported is located.
         * @param {string} eventId The event to report.
         * @param {InlineObject33} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContent: async (roomId: string, eventId: string, body?: InlineObject33, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling reportContent.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling reportContent.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/report/{eventId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportingContentApi - functional programming interface
 * @export
 */
export const ReportingContentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Reports an event as inappropriate to the server, which may then notify the appropriate people.
         * @summary Reports an event as inappropriate.
         * @param {string} roomId The room in which the event being reported is located.
         * @param {string} eventId The event to report.
         * @param {InlineObject33} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportContent(roomId: string, eventId: string, body?: InlineObject33, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await ReportingContentApiAxiosParamCreator(configuration).reportContent(roomId, eventId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReportingContentApi - factory interface
 * @export
 */
export const ReportingContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Reports an event as inappropriate to the server, which may then notify the appropriate people.
         * @summary Reports an event as inappropriate.
         * @param {string} roomId The room in which the event being reported is located.
         * @param {string} eventId The event to report.
         * @param {InlineObject33} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContent(roomId: string, eventId: string, body?: InlineObject33, options?: any): AxiosPromise<object> {
            return ReportingContentApiFp(configuration).reportContent(roomId, eventId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportingContentApi - object-oriented interface
 * @export
 * @class ReportingContentApi
 * @extends {BaseAPI}
 */
export class ReportingContentApi extends BaseAPI {
    /**
     * Reports an event as inappropriate to the server, which may then notify the appropriate people.
     * @summary Reports an event as inappropriate.
     * @param {string} roomId The room in which the event being reported is located.
     * @param {string} eventId The event to report.
     * @param {InlineObject33} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingContentApi
     */
    public reportContent(roomId: string, eventId: string, body?: InlineObject33, options?: any) {
        return ReportingContentApiFp(this.configuration).reportContent(roomId, eventId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoomCreationApi - axios parameter creator
 * @export
 */
export const RoomCreationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new room with various configuration options.  The server MUST apply the normal state resolution rules when creating the new room, including checking power levels for each event. It MUST apply the events implied by the request in the following order:  1. The ``m.room.create`` event itself. Must be the first event in the    room.  2. An ``m.room.member`` event for the creator to join the room. This is    needed so the remaining events can be sent.  3. A default ``m.room.power_levels`` event, giving the room creator    (and not other members) permission to send state events. Overridden    by the ``power_level_content_override`` parameter.  4. Events set by the ``preset``. Currently these are the ``m.room.join_rules``,    ``m.room.history_visibility``, and ``m.room.guest_access`` state events.  5. Events listed in ``initial_state``, in the order that they are    listed.  6. Events implied by ``name`` and ``topic`` (``m.room.name`` and ``m.room.topic``    state events).  7. Invite events implied by ``invite`` and ``invite_3pid`` (``m.room.member`` with    ``membership: invite`` and ``m.room.third_party_invite``).  The available presets do the following with respect to room state:  ========================  ==============  ======================  ================  =========          Preset           ``join_rules``  ``history_visibility``  ``guest_access``  Other ========================  ==============  ======================  ================  ========= ``private_chat``          ``invite``      ``shared``              ``can_join`` ``trusted_private_chat``  ``invite``      ``shared``              ``can_join``      All invitees are given the same power level as the room creator. ``public_chat``           ``public``      ``shared``              ``forbidden`` ========================  ==============  ======================  ================  =========  The server will create a ``m.room.create`` event in the room with the requesting user as the creator, alongside other keys provided in the ``creation_content``.
         * @summary Create a new room
         * @param {InlineObject6} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom: async (body?: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/createRoom`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomCreationApi - functional programming interface
 * @export
 */
export const RoomCreationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new room with various configuration options.  The server MUST apply the normal state resolution rules when creating the new room, including checking power levels for each event. It MUST apply the events implied by the request in the following order:  1. The ``m.room.create`` event itself. Must be the first event in the    room.  2. An ``m.room.member`` event for the creator to join the room. This is    needed so the remaining events can be sent.  3. A default ``m.room.power_levels`` event, giving the room creator    (and not other members) permission to send state events. Overridden    by the ``power_level_content_override`` parameter.  4. Events set by the ``preset``. Currently these are the ``m.room.join_rules``,    ``m.room.history_visibility``, and ``m.room.guest_access`` state events.  5. Events listed in ``initial_state``, in the order that they are    listed.  6. Events implied by ``name`` and ``topic`` (``m.room.name`` and ``m.room.topic``    state events).  7. Invite events implied by ``invite`` and ``invite_3pid`` (``m.room.member`` with    ``membership: invite`` and ``m.room.third_party_invite``).  The available presets do the following with respect to room state:  ========================  ==============  ======================  ================  =========          Preset           ``join_rules``  ``history_visibility``  ``guest_access``  Other ========================  ==============  ======================  ================  ========= ``private_chat``          ``invite``      ``shared``              ``can_join`` ``trusted_private_chat``  ``invite``      ``shared``              ``can_join``      All invitees are given the same power level as the room creator. ``public_chat``           ``public``      ``shared``              ``forbidden`` ========================  ==============  ======================  ================  =========  The server will create a ``m.room.create`` event in the room with the requesting user as the creator, alongside other keys provided in the ``creation_content``.
         * @summary Create a new room
         * @param {InlineObject6} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoom(body?: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await RoomCreationApiAxiosParamCreator(configuration).createRoom(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoomCreationApi - factory interface
 * @export
 */
export const RoomCreationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new room with various configuration options.  The server MUST apply the normal state resolution rules when creating the new room, including checking power levels for each event. It MUST apply the events implied by the request in the following order:  1. The ``m.room.create`` event itself. Must be the first event in the    room.  2. An ``m.room.member`` event for the creator to join the room. This is    needed so the remaining events can be sent.  3. A default ``m.room.power_levels`` event, giving the room creator    (and not other members) permission to send state events. Overridden    by the ``power_level_content_override`` parameter.  4. Events set by the ``preset``. Currently these are the ``m.room.join_rules``,    ``m.room.history_visibility``, and ``m.room.guest_access`` state events.  5. Events listed in ``initial_state``, in the order that they are    listed.  6. Events implied by ``name`` and ``topic`` (``m.room.name`` and ``m.room.topic``    state events).  7. Invite events implied by ``invite`` and ``invite_3pid`` (``m.room.member`` with    ``membership: invite`` and ``m.room.third_party_invite``).  The available presets do the following with respect to room state:  ========================  ==============  ======================  ================  =========          Preset           ``join_rules``  ``history_visibility``  ``guest_access``  Other ========================  ==============  ======================  ================  ========= ``private_chat``          ``invite``      ``shared``              ``can_join`` ``trusted_private_chat``  ``invite``      ``shared``              ``can_join``      All invitees are given the same power level as the room creator. ``public_chat``           ``public``      ``shared``              ``forbidden`` ========================  ==============  ======================  ================  =========  The server will create a ``m.room.create`` event in the room with the requesting user as the creator, alongside other keys provided in the ``creation_content``.
         * @summary Create a new room
         * @param {InlineObject6} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom(body?: InlineObject6, options?: any): AxiosPromise<InlineResponse2007> {
            return RoomCreationApiFp(configuration).createRoom(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomCreationApi - object-oriented interface
 * @export
 * @class RoomCreationApi
 * @extends {BaseAPI}
 */
export class RoomCreationApi extends BaseAPI {
    /**
     * Create a new room with various configuration options.  The server MUST apply the normal state resolution rules when creating the new room, including checking power levels for each event. It MUST apply the events implied by the request in the following order:  1. The ``m.room.create`` event itself. Must be the first event in the    room.  2. An ``m.room.member`` event for the creator to join the room. This is    needed so the remaining events can be sent.  3. A default ``m.room.power_levels`` event, giving the room creator    (and not other members) permission to send state events. Overridden    by the ``power_level_content_override`` parameter.  4. Events set by the ``preset``. Currently these are the ``m.room.join_rules``,    ``m.room.history_visibility``, and ``m.room.guest_access`` state events.  5. Events listed in ``initial_state``, in the order that they are    listed.  6. Events implied by ``name`` and ``topic`` (``m.room.name`` and ``m.room.topic``    state events).  7. Invite events implied by ``invite`` and ``invite_3pid`` (``m.room.member`` with    ``membership: invite`` and ``m.room.third_party_invite``).  The available presets do the following with respect to room state:  ========================  ==============  ======================  ================  =========          Preset           ``join_rules``  ``history_visibility``  ``guest_access``  Other ========================  ==============  ======================  ================  ========= ``private_chat``          ``invite``      ``shared``              ``can_join`` ``trusted_private_chat``  ``invite``      ``shared``              ``can_join``      All invitees are given the same power level as the room creator. ``public_chat``           ``public``      ``shared``              ``forbidden`` ========================  ==============  ======================  ================  =========  The server will create a ``m.room.create`` event in the room with the requesting user as the creator, alongside other keys provided in the ``creation_content``.
     * @summary Create a new room
     * @param {InlineObject6} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomCreationApi
     */
    public createRoom(body?: InlineObject6, options?: any) {
        return RoomCreationApiFp(this.configuration).createRoom(body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoomDirectoryApi - axios parameter creator
 * @export
 */
export const RoomDirectoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a mapping of room alias to room ID.  Servers may choose to implement additional access control checks here, for instance that room aliases can only be deleted by their creator or a server administrator.  .. Note::    Servers may choose to update the ``alt_aliases`` for the ``m.room.canonical_alias``    state event in the room when an alias is removed. Servers which choose to update the    canonical alias event are recommended to, in addition to their other relevant permission    checks, delete the alias and return a successful response even if the user does not    have permission to update the ``m.room.canonical_alias`` event.
         * @summary Remove a mapping of room alias to room ID.
         * @param {string} roomAlias The room alias to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomAlias: async (roomAlias: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomAlias' is not null or undefined
            if (roomAlias === null || roomAlias === undefined) {
                throw new RequiredError('roomAlias','Required parameter roomAlias was null or undefined when calling deleteRoomAlias.');
            }
            const localVarPath = `/_matrix/client/r0/directory/room/{roomAlias}`
                .replace(`{${"roomAlias"}}`, encodeURIComponent(String(roomAlias)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of aliases maintained by the local server for the given room.  This endpoint can be called by users who are in the room (external users receive an ``M_FORBIDDEN`` error response). If the room\'s ``m.room.history_visibility`` maps to ``world_readable``, any user can call this endpoint.  Servers may choose to implement additional access control checks here, such as allowing server administrators to view aliases regardless of membership.  .. Note::    Clients are recommended not to display this list of aliases prominently    as they are not curated, unlike those listed in the ``m.room.canonical_alias``    state event.
         * @summary Get a list of local aliases on a given room.
         * @param {string} roomId The room ID to find local aliases of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalAliases: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getLocalAliases.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/aliases`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests that the server resolve a room alias to a room ID.  The server will use the federation API to resolve the alias if the domain part of the alias does not correspond to the server\'s own domain.
         * @summary Get the room ID corresponding to this room alias.
         * @param {string} roomAlias The room alias.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomIdByAlias: async (roomAlias: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomAlias' is not null or undefined
            if (roomAlias === null || roomAlias === undefined) {
                throw new RequiredError('roomAlias','Required parameter roomAlias was null or undefined when calling getRoomIdByAlias.');
            }
            const localVarPath = `/_matrix/client/r0/directory/room/{roomAlias}`
                .replace(`{${"roomAlias"}}`, encodeURIComponent(String(roomAlias)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new mapping from room alias to room ID.
         * @param {string} roomAlias The room alias to set.
         * @param {InlineObject11} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomAlias: async (roomAlias: string, body: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomAlias' is not null or undefined
            if (roomAlias === null || roomAlias === undefined) {
                throw new RequiredError('roomAlias','Required parameter roomAlias was null or undefined when calling setRoomAlias.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setRoomAlias.');
            }
            const localVarPath = `/_matrix/client/r0/directory/room/{roomAlias}`
                .replace(`{${"roomAlias"}}`, encodeURIComponent(String(roomAlias)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomDirectoryApi - functional programming interface
 * @export
 */
export const RoomDirectoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove a mapping of room alias to room ID.  Servers may choose to implement additional access control checks here, for instance that room aliases can only be deleted by their creator or a server administrator.  .. Note::    Servers may choose to update the ``alt_aliases`` for the ``m.room.canonical_alias``    state event in the room when an alias is removed. Servers which choose to update the    canonical alias event are recommended to, in addition to their other relevant permission    checks, delete the alias and return a successful response even if the user does not    have permission to update the ``m.room.canonical_alias`` event.
         * @summary Remove a mapping of room alias to room ID.
         * @param {string} roomAlias The room alias to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoomAlias(roomAlias: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomDirectoryApiAxiosParamCreator(configuration).deleteRoomAlias(roomAlias, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a list of aliases maintained by the local server for the given room.  This endpoint can be called by users who are in the room (external users receive an ``M_FORBIDDEN`` error response). If the room\'s ``m.room.history_visibility`` maps to ``world_readable``, any user can call this endpoint.  Servers may choose to implement additional access control checks here, such as allowing server administrators to view aliases regardless of membership.  .. Note::    Clients are recommended not to display this list of aliases prominently    as they are not curated, unlike those listed in the ``m.room.canonical_alias``    state event.
         * @summary Get a list of local aliases on a given room.
         * @param {string} roomId The room ID to find local aliases of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalAliases(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await RoomDirectoryApiAxiosParamCreator(configuration).getLocalAliases(roomId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests that the server resolve a room alias to a room ID.  The server will use the federation API to resolve the alias if the domain part of the alias does not correspond to the server\'s own domain.
         * @summary Get the room ID corresponding to this room alias.
         * @param {string} roomAlias The room alias.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomIdByAlias(roomAlias: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await RoomDirectoryApiAxiosParamCreator(configuration).getRoomIdByAlias(roomAlias, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a new mapping from room alias to room ID.
         * @param {string} roomAlias The room alias to set.
         * @param {InlineObject11} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoomAlias(roomAlias: string, body: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomDirectoryApiAxiosParamCreator(configuration).setRoomAlias(roomAlias, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoomDirectoryApi - factory interface
 * @export
 */
export const RoomDirectoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Remove a mapping of room alias to room ID.  Servers may choose to implement additional access control checks here, for instance that room aliases can only be deleted by their creator or a server administrator.  .. Note::    Servers may choose to update the ``alt_aliases`` for the ``m.room.canonical_alias``    state event in the room when an alias is removed. Servers which choose to update the    canonical alias event are recommended to, in addition to their other relevant permission    checks, delete the alias and return a successful response even if the user does not    have permission to update the ``m.room.canonical_alias`` event.
         * @summary Remove a mapping of room alias to room ID.
         * @param {string} roomAlias The room alias to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomAlias(roomAlias: string, options?: any): AxiosPromise<object> {
            return RoomDirectoryApiFp(configuration).deleteRoomAlias(roomAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of aliases maintained by the local server for the given room.  This endpoint can be called by users who are in the room (external users receive an ``M_FORBIDDEN`` error response). If the room\'s ``m.room.history_visibility`` maps to ``world_readable``, any user can call this endpoint.  Servers may choose to implement additional access control checks here, such as allowing server administrators to view aliases regardless of membership.  .. Note::    Clients are recommended not to display this list of aliases prominently    as they are not curated, unlike those listed in the ``m.room.canonical_alias``    state event.
         * @summary Get a list of local aliases on a given room.
         * @param {string} roomId The room ID to find local aliases of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalAliases(roomId: string, options?: any): AxiosPromise<InlineResponse20036> {
            return RoomDirectoryApiFp(configuration).getLocalAliases(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests that the server resolve a room alias to a room ID.  The server will use the federation API to resolve the alias if the domain part of the alias does not correspond to the server\'s own domain.
         * @summary Get the room ID corresponding to this room alias.
         * @param {string} roomAlias The room alias.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomIdByAlias(roomAlias: string, options?: any): AxiosPromise<InlineResponse20010> {
            return RoomDirectoryApiFp(configuration).getRoomIdByAlias(roomAlias, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new mapping from room alias to room ID.
         * @param {string} roomAlias The room alias to set.
         * @param {InlineObject11} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomAlias(roomAlias: string, body: InlineObject11, options?: any): AxiosPromise<object> {
            return RoomDirectoryApiFp(configuration).setRoomAlias(roomAlias, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomDirectoryApi - object-oriented interface
 * @export
 * @class RoomDirectoryApi
 * @extends {BaseAPI}
 */
export class RoomDirectoryApi extends BaseAPI {
    /**
     * Remove a mapping of room alias to room ID.  Servers may choose to implement additional access control checks here, for instance that room aliases can only be deleted by their creator or a server administrator.  .. Note::    Servers may choose to update the ``alt_aliases`` for the ``m.room.canonical_alias``    state event in the room when an alias is removed. Servers which choose to update the    canonical alias event are recommended to, in addition to their other relevant permission    checks, delete the alias and return a successful response even if the user does not    have permission to update the ``m.room.canonical_alias`` event.
     * @summary Remove a mapping of room alias to room ID.
     * @param {string} roomAlias The room alias to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDirectoryApi
     */
    public deleteRoomAlias(roomAlias: string, options?: any) {
        return RoomDirectoryApiFp(this.configuration).deleteRoomAlias(roomAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of aliases maintained by the local server for the given room.  This endpoint can be called by users who are in the room (external users receive an ``M_FORBIDDEN`` error response). If the room\'s ``m.room.history_visibility`` maps to ``world_readable``, any user can call this endpoint.  Servers may choose to implement additional access control checks here, such as allowing server administrators to view aliases regardless of membership.  .. Note::    Clients are recommended not to display this list of aliases prominently    as they are not curated, unlike those listed in the ``m.room.canonical_alias``    state event.
     * @summary Get a list of local aliases on a given room.
     * @param {string} roomId The room ID to find local aliases of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDirectoryApi
     */
    public getLocalAliases(roomId: string, options?: any) {
        return RoomDirectoryApiFp(this.configuration).getLocalAliases(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests that the server resolve a room alias to a room ID.  The server will use the federation API to resolve the alias if the domain part of the alias does not correspond to the server\'s own domain.
     * @summary Get the room ID corresponding to this room alias.
     * @param {string} roomAlias The room alias.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDirectoryApi
     */
    public getRoomIdByAlias(roomAlias: string, options?: any) {
        return RoomDirectoryApiFp(this.configuration).getRoomIdByAlias(roomAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a new mapping from room alias to room ID.
     * @param {string} roomAlias The room alias to set.
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDirectoryApi
     */
    public setRoomAlias(roomAlias: string, body: InlineObject11, options?: any) {
        return RoomDirectoryApiFp(this.configuration).setRoomAlias(roomAlias, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoomDiscoveryApi - axios parameter creator
 * @export
 */
export const RoomDiscoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists the public rooms on the server.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
         * @summary Lists the public rooms on the server.
         * @param {number} [limit] Limit the number of results returned.
         * @param {string} [since] A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag.
         * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicRooms: async (limit?: number, since?: string, server?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/publicRooms`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the public rooms on the server, with optional filter.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
         * @summary Lists the public rooms on the server with optional filter.
         * @param {InlineObject20} body
         * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPublicRooms: async (body: InlineObject20, server?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queryPublicRooms.');
            }
            const localVarPath = `/_matrix/client/r0/publicRooms`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomDiscoveryApi - functional programming interface
 * @export
 */
export const RoomDiscoveryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists the public rooms on the server.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
         * @summary Lists the public rooms on the server.
         * @param {number} [limit] Limit the number of results returned.
         * @param {string} [since] A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag.
         * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicRooms(limit?: number, since?: string, server?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await RoomDiscoveryApiAxiosParamCreator(configuration).getPublicRooms(limit, since, server, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists the public rooms on the server, with optional filter.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
         * @summary Lists the public rooms on the server with optional filter.
         * @param {InlineObject20} body
         * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryPublicRooms(body: InlineObject20, server?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await RoomDiscoveryApiAxiosParamCreator(configuration).queryPublicRooms(body, server, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoomDiscoveryApi - factory interface
 * @export
 */
export const RoomDiscoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Lists the public rooms on the server.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
         * @summary Lists the public rooms on the server.
         * @param {number} [limit] Limit the number of results returned.
         * @param {string} [since] A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag.
         * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicRooms(limit?: number, since?: string, server?: string, options?: any): AxiosPromise<InlineResponse20027> {
            return RoomDiscoveryApiFp(configuration).getPublicRooms(limit, since, server, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the public rooms on the server, with optional filter.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
         * @summary Lists the public rooms on the server with optional filter.
         * @param {InlineObject20} body
         * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPublicRooms(body: InlineObject20, server?: string, options?: any): AxiosPromise<InlineResponse20028> {
            return RoomDiscoveryApiFp(configuration).queryPublicRooms(body, server, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomDiscoveryApi - object-oriented interface
 * @export
 * @class RoomDiscoveryApi
 * @extends {BaseAPI}
 */
export class RoomDiscoveryApi extends BaseAPI {
    /**
     * Lists the public rooms on the server.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
     * @summary Lists the public rooms on the server.
     * @param {number} [limit] Limit the number of results returned.
     * @param {string} [since] A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag.
     * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDiscoveryApi
     */
    public getPublicRooms(limit?: number, since?: string, server?: string, options?: any) {
        return RoomDiscoveryApiFp(this.configuration).getPublicRooms(limit, since, server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the public rooms on the server, with optional filter.  This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.
     * @summary Lists the public rooms on the server with optional filter.
     * @param {InlineObject20} body
     * @param {string} [server] The server to fetch the public room lists from. Defaults to the local server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDiscoveryApi
     */
    public queryPublicRooms(body: InlineObject20, server?: string, options?: any) {
        return RoomDiscoveryApiFp(this.configuration).queryPublicRooms(body, server, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoomMembershipApi - axios parameter creator
 * @export
 */
export const RoomMembershipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ban a user in the room. If the user is currently in the room, also kick them.  When a user is banned from a room, they may not join it or be invited to it until they are unbanned.  The caller must have the required power level in order to perform this operation.
         * @summary Ban a user in the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be banned.
         * @param {InlineObject26} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban: async (roomId: string, body: InlineObject26, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling ban.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling ban.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/ban`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API stops a user remembering about a particular room.  In general, history is a first class citizen in Matrix. After this API is called, however, a user will no longer be able to retrieve history for this room. If all users on a homeserver forget a room, the room is eligible for deletion from that homeserver.  If the user is currently joined to the room, they must leave the room before calling this API.
         * @summary Stop the requesting user remembering about a particular room.
         * @param {string} roomId The room identifier to forget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetRoom: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling forgetRoom.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/forget`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of the user\'s current rooms.
         * @summary Lists the user\'s current rooms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoinedRooms: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/joined_rooms`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * .. _invite-by-third-party-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API does not require that the inviter know the Matrix identifier of the invitee, and instead relies on third party identifiers. The homeserver uses an identity server to perform the mapping from third party identifier to a Matrix identifier. The other is documented in the* `joining rooms section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the identity server did know the Matrix user identifier for the third party identifier, the homeserver will append a ``m.room.member`` event to the room.  If the identity server does not know a Matrix user identifier for the passed third party identifier, the homeserver will issue an invitation which can be accepted upon providing proof of ownership of the third party identifier. This is achieved by the identity server generating a token, which it gives to the inviting homeserver. The homeserver will add an ``m.room.third_party_invite`` event into the graph for the room, containing that token.  When the invitee binds the invited third party identifier to a Matrix user ID, the identity server will give the user a list of pending invitations, each containing:  - The room ID to which they were invited  - The token given to the homeserver  - A signature of the token, signed with the identity server\'s private key  - The matrix user ID who invited them to the room  If a token is requested from the identity server, the homeserver will append a ``m.room.third_party_invite`` event to the room.  .. _joining rooms section: `invite-by-user-id-endpoint`_
         * @summary Invite a user to participate in a particular room.
         * @param {string} roomId The room identifier (not alias) to which to invite the user.
         * @param {InlineObject27} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteBy3PID: async (roomId: string, body: InlineObject27, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling inviteBy3PID.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling inviteBy3PID.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/invite`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * .. _invite-by-user-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API requires that the inviter knows the Matrix identifier of the invitee. The other is documented in the* `third party invites section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the user was invited to the room, the homeserver will append a ``m.room.member`` event to the room.  .. _third party invites section: `invite-by-third-party-id-endpoint`_
         * @summary Invite a user to participate in a particular room.
         * @param {string} roomId The room identifier (not alias) to which to invite the user.
         * @param {InlineObject28} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (roomId: string, body: InlineObject28, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling inviteUser.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling inviteUser.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/invite `
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * *Note that this API takes either a room ID or alias, unlike* ``/room/{roomId}/join``.  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
         * @summary Start the requesting user participating in a particular room.
         * @param {string} roomIdOrAlias The room identifier or alias to join.
         * @param {Array<string>} [serverName] The servers to attempt to join the room through. One of the servers must be participating in the room.
         * @param {InlineObject12} [thirdPartySigned]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoom: async (roomIdOrAlias: string, serverName?: Array<string>, thirdPartySigned?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomIdOrAlias' is not null or undefined
            if (roomIdOrAlias === null || roomIdOrAlias === undefined) {
                throw new RequiredError('roomIdOrAlias','Required parameter roomIdOrAlias was null or undefined when calling joinRoom.');
            }
            const localVarPath = `/_matrix/client/r0/join/{roomIdOrAlias}`
                .replace(`{${"roomIdOrAlias"}}`, encodeURIComponent(String(roomIdOrAlias)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (serverName) {
                localVarQueryParameter['server_name'] = serverName.join(COLLECTION_FORMATS.csv);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof thirdPartySigned !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(thirdPartySigned !== undefined ? thirdPartySigned : {}) : (thirdPartySigned || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * *Note that this API requires a room ID, not alias.* ``/join/{roomIdOrAlias}`` *exists if you have a room alias.*  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
         * @summary Start the requesting user participating in a particular room.
         * @param {string} roomId The room identifier (not alias) to join.
         * @param {InlineObject29} [thirdPartySigned]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoomById: async (roomId: string, thirdPartySigned?: InlineObject29, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling joinRoomById.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/join`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof thirdPartySigned !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(thirdPartySigned !== undefined ? thirdPartySigned : {}) : (thirdPartySigned || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kick a user from the room.  The caller must have the required power level in order to perform this operation.  Kicking a user adjusts the target member\'s membership state to be ``leave`` with an optional ``reason``. Like with other membership changes, a user can directly adjust the target member\'s state by making a request to ``/rooms/<room id>/state/m.room.member/<user id>``.
         * @summary Kick a user from the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be kicked.
         * @param {InlineObject30} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kick: async (roomId: string, body: InlineObject30, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling kick.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling kick.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/kick`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API stops a user participating in a particular room.  If the user was already in the room, they will no longer be able to see new events in the room. If the room requires an invite to join, they will need to be re-invited before they can re-join.  If the user was invited to the room, but had not joined, this call serves to reject the invite.  The user will still be allowed to retrieve history from the room which they were previously allowed to see.
         * @summary Stop the requesting user participating in a particular room.
         * @param {string} roomId The room identifier to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoom: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling leaveRoom.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/leave`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unban a user from the room. This allows them to be invited to the room, and join if they would otherwise be allowed to join according to its join rules.  The caller must have the required power level in order to perform this operation.
         * @summary Unban a user from the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be unbanned.
         * @param {InlineObject35} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unban: async (roomId: string, body: InlineObject35, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling unban.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling unban.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/unban`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomMembershipApi - functional programming interface
 * @export
 */
export const RoomMembershipApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Ban a user in the room. If the user is currently in the room, also kick them.  When a user is banned from a room, they may not join it or be invited to it until they are unbanned.  The caller must have the required power level in order to perform this operation.
         * @summary Ban a user in the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be banned.
         * @param {InlineObject26} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ban(roomId: string, body: InlineObject26, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).ban(roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API stops a user remembering about a particular room.  In general, history is a first class citizen in Matrix. After this API is called, however, a user will no longer be able to retrieve history for this room. If all users on a homeserver forget a room, the room is eligible for deletion from that homeserver.  If the user is currently joined to the room, they must leave the room before calling this API.
         * @summary Stop the requesting user remembering about a particular room.
         * @param {string} roomId The room identifier to forget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgetRoom(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).forgetRoom(roomId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API returns a list of the user\'s current rooms.
         * @summary Lists the user\'s current rooms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJoinedRooms(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).getJoinedRooms(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * .. _invite-by-third-party-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API does not require that the inviter know the Matrix identifier of the invitee, and instead relies on third party identifiers. The homeserver uses an identity server to perform the mapping from third party identifier to a Matrix identifier. The other is documented in the* `joining rooms section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the identity server did know the Matrix user identifier for the third party identifier, the homeserver will append a ``m.room.member`` event to the room.  If the identity server does not know a Matrix user identifier for the passed third party identifier, the homeserver will issue an invitation which can be accepted upon providing proof of ownership of the third party identifier. This is achieved by the identity server generating a token, which it gives to the inviting homeserver. The homeserver will add an ``m.room.third_party_invite`` event into the graph for the room, containing that token.  When the invitee binds the invited third party identifier to a Matrix user ID, the identity server will give the user a list of pending invitations, each containing:  - The room ID to which they were invited  - The token given to the homeserver  - A signature of the token, signed with the identity server\'s private key  - The matrix user ID who invited them to the room  If a token is requested from the identity server, the homeserver will append a ``m.room.third_party_invite`` event to the room.  .. _joining rooms section: `invite-by-user-id-endpoint`_
         * @summary Invite a user to participate in a particular room.
         * @param {string} roomId The room identifier (not alias) to which to invite the user.
         * @param {InlineObject27} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteBy3PID(roomId: string, body: InlineObject27, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).inviteBy3PID(roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * .. _invite-by-user-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API requires that the inviter knows the Matrix identifier of the invitee. The other is documented in the* `third party invites section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the user was invited to the room, the homeserver will append a ``m.room.member`` event to the room.  .. _third party invites section: `invite-by-third-party-id-endpoint`_
         * @summary Invite a user to participate in a particular room.
         * @param {string} roomId The room identifier (not alias) to which to invite the user.
         * @param {InlineObject28} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(roomId: string, body: InlineObject28, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).inviteUser(roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * *Note that this API takes either a room ID or alias, unlike* ``/room/{roomId}/join``.  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
         * @summary Start the requesting user participating in a particular room.
         * @param {string} roomIdOrAlias The room identifier or alias to join.
         * @param {Array<string>} [serverName] The servers to attempt to join the room through. One of the servers must be participating in the room.
         * @param {InlineObject12} [thirdPartySigned]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinRoom(roomIdOrAlias: string, serverName?: Array<string>, thirdPartySigned?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).joinRoom(roomIdOrAlias, serverName, thirdPartySigned, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * *Note that this API requires a room ID, not alias.* ``/join/{roomIdOrAlias}`` *exists if you have a room alias.*  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
         * @summary Start the requesting user participating in a particular room.
         * @param {string} roomId The room identifier (not alias) to join.
         * @param {InlineObject29} [thirdPartySigned]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinRoomById(roomId: string, thirdPartySigned?: InlineObject29, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).joinRoomById(roomId, thirdPartySigned, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Kick a user from the room.  The caller must have the required power level in order to perform this operation.  Kicking a user adjusts the target member\'s membership state to be ``leave`` with an optional ``reason``. Like with other membership changes, a user can directly adjust the target member\'s state by making a request to ``/rooms/<room id>/state/m.room.member/<user id>``.
         * @summary Kick a user from the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be kicked.
         * @param {InlineObject30} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kick(roomId: string, body: InlineObject30, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).kick(roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API stops a user participating in a particular room.  If the user was already in the room, they will no longer be able to see new events in the room. If the room requires an invite to join, they will need to be re-invited before they can re-join.  If the user was invited to the room, but had not joined, this call serves to reject the invite.  The user will still be allowed to retrieve history from the room which they were previously allowed to see.
         * @summary Stop the requesting user participating in a particular room.
         * @param {string} roomId The room identifier to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveRoom(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).leaveRoom(roomId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unban a user from the room. This allows them to be invited to the room, and join if they would otherwise be allowed to join according to its join rules.  The caller must have the required power level in order to perform this operation.
         * @summary Unban a user from the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be unbanned.
         * @param {InlineObject35} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unban(roomId: string, body: InlineObject35, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomMembershipApiAxiosParamCreator(configuration).unban(roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoomMembershipApi - factory interface
 * @export
 */
export const RoomMembershipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Ban a user in the room. If the user is currently in the room, also kick them.  When a user is banned from a room, they may not join it or be invited to it until they are unbanned.  The caller must have the required power level in order to perform this operation.
         * @summary Ban a user in the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be banned.
         * @param {InlineObject26} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban(roomId: string, body: InlineObject26, options?: any): AxiosPromise<object> {
            return RoomMembershipApiFp(configuration).ban(roomId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This API stops a user remembering about a particular room.  In general, history is a first class citizen in Matrix. After this API is called, however, a user will no longer be able to retrieve history for this room. If all users on a homeserver forget a room, the room is eligible for deletion from that homeserver.  If the user is currently joined to the room, they must leave the room before calling this API.
         * @summary Stop the requesting user remembering about a particular room.
         * @param {string} roomId The room identifier to forget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetRoom(roomId: string, options?: any): AxiosPromise<object> {
            return RoomMembershipApiFp(configuration).forgetRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of the user\'s current rooms.
         * @summary Lists the user\'s current rooms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoinedRooms(options?: any): AxiosPromise<InlineResponse20015> {
            return RoomMembershipApiFp(configuration).getJoinedRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * .. _invite-by-third-party-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API does not require that the inviter know the Matrix identifier of the invitee, and instead relies on third party identifiers. The homeserver uses an identity server to perform the mapping from third party identifier to a Matrix identifier. The other is documented in the* `joining rooms section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the identity server did know the Matrix user identifier for the third party identifier, the homeserver will append a ``m.room.member`` event to the room.  If the identity server does not know a Matrix user identifier for the passed third party identifier, the homeserver will issue an invitation which can be accepted upon providing proof of ownership of the third party identifier. This is achieved by the identity server generating a token, which it gives to the inviting homeserver. The homeserver will add an ``m.room.third_party_invite`` event into the graph for the room, containing that token.  When the invitee binds the invited third party identifier to a Matrix user ID, the identity server will give the user a list of pending invitations, each containing:  - The room ID to which they were invited  - The token given to the homeserver  - A signature of the token, signed with the identity server\'s private key  - The matrix user ID who invited them to the room  If a token is requested from the identity server, the homeserver will append a ``m.room.third_party_invite`` event to the room.  .. _joining rooms section: `invite-by-user-id-endpoint`_
         * @summary Invite a user to participate in a particular room.
         * @param {string} roomId The room identifier (not alias) to which to invite the user.
         * @param {InlineObject27} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteBy3PID(roomId: string, body: InlineObject27, options?: any): AxiosPromise<object> {
            return RoomMembershipApiFp(configuration).inviteBy3PID(roomId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * .. _invite-by-user-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API requires that the inviter knows the Matrix identifier of the invitee. The other is documented in the* `third party invites section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the user was invited to the room, the homeserver will append a ``m.room.member`` event to the room.  .. _third party invites section: `invite-by-third-party-id-endpoint`_
         * @summary Invite a user to participate in a particular room.
         * @param {string} roomId The room identifier (not alias) to which to invite the user.
         * @param {InlineObject28} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser(roomId: string, body: InlineObject28, options?: any): AxiosPromise<object> {
            return RoomMembershipApiFp(configuration).inviteUser(roomId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * *Note that this API takes either a room ID or alias, unlike* ``/room/{roomId}/join``.  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
         * @summary Start the requesting user participating in a particular room.
         * @param {string} roomIdOrAlias The room identifier or alias to join.
         * @param {Array<string>} [serverName] The servers to attempt to join the room through. One of the servers must be participating in the room.
         * @param {InlineObject12} [thirdPartySigned]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoom(roomIdOrAlias: string, serverName?: Array<string>, thirdPartySigned?: InlineObject12, options?: any): AxiosPromise<InlineResponse20014> {
            return RoomMembershipApiFp(configuration).joinRoom(roomIdOrAlias, serverName, thirdPartySigned, options).then((request) => request(axios, basePath));
        },
        /**
         * *Note that this API requires a room ID, not alias.* ``/join/{roomIdOrAlias}`` *exists if you have a room alias.*  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
         * @summary Start the requesting user participating in a particular room.
         * @param {string} roomId The room identifier (not alias) to join.
         * @param {InlineObject29} [thirdPartySigned]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoomById(roomId: string, thirdPartySigned?: InlineObject29, options?: any): AxiosPromise<InlineResponse20014> {
            return RoomMembershipApiFp(configuration).joinRoomById(roomId, thirdPartySigned, options).then((request) => request(axios, basePath));
        },
        /**
         * Kick a user from the room.  The caller must have the required power level in order to perform this operation.  Kicking a user adjusts the target member\'s membership state to be ``leave`` with an optional ``reason``. Like with other membership changes, a user can directly adjust the target member\'s state by making a request to ``/rooms/<room id>/state/m.room.member/<user id>``.
         * @summary Kick a user from the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be kicked.
         * @param {InlineObject30} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kick(roomId: string, body: InlineObject30, options?: any): AxiosPromise<object> {
            return RoomMembershipApiFp(configuration).kick(roomId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This API stops a user participating in a particular room.  If the user was already in the room, they will no longer be able to see new events in the room. If the room requires an invite to join, they will need to be re-invited before they can re-join.  If the user was invited to the room, but had not joined, this call serves to reject the invite.  The user will still be allowed to retrieve history from the room which they were previously allowed to see.
         * @summary Stop the requesting user participating in a particular room.
         * @param {string} roomId The room identifier to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoom(roomId: string, options?: any): AxiosPromise<object> {
            return RoomMembershipApiFp(configuration).leaveRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unban a user from the room. This allows them to be invited to the room, and join if they would otherwise be allowed to join according to its join rules.  The caller must have the required power level in order to perform this operation.
         * @summary Unban a user from the room.
         * @param {string} roomId The room identifier (not alias) from which the user should be unbanned.
         * @param {InlineObject35} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unban(roomId: string, body: InlineObject35, options?: any): AxiosPromise<object> {
            return RoomMembershipApiFp(configuration).unban(roomId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomMembershipApi - object-oriented interface
 * @export
 * @class RoomMembershipApi
 * @extends {BaseAPI}
 */
export class RoomMembershipApi extends BaseAPI {
    /**
     * Ban a user in the room. If the user is currently in the room, also kick them.  When a user is banned from a room, they may not join it or be invited to it until they are unbanned.  The caller must have the required power level in order to perform this operation.
     * @summary Ban a user in the room.
     * @param {string} roomId The room identifier (not alias) from which the user should be banned.
     * @param {InlineObject26} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public ban(roomId: string, body: InlineObject26, options?: any) {
        return RoomMembershipApiFp(this.configuration).ban(roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API stops a user remembering about a particular room.  In general, history is a first class citizen in Matrix. After this API is called, however, a user will no longer be able to retrieve history for this room. If all users on a homeserver forget a room, the room is eligible for deletion from that homeserver.  If the user is currently joined to the room, they must leave the room before calling this API.
     * @summary Stop the requesting user remembering about a particular room.
     * @param {string} roomId The room identifier to forget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public forgetRoom(roomId: string, options?: any) {
        return RoomMembershipApiFp(this.configuration).forgetRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of the user\'s current rooms.
     * @summary Lists the user\'s current rooms.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public getJoinedRooms(options?: any) {
        return RoomMembershipApiFp(this.configuration).getJoinedRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * .. _invite-by-third-party-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API does not require that the inviter know the Matrix identifier of the invitee, and instead relies on third party identifiers. The homeserver uses an identity server to perform the mapping from third party identifier to a Matrix identifier. The other is documented in the* `joining rooms section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the identity server did know the Matrix user identifier for the third party identifier, the homeserver will append a ``m.room.member`` event to the room.  If the identity server does not know a Matrix user identifier for the passed third party identifier, the homeserver will issue an invitation which can be accepted upon providing proof of ownership of the third party identifier. This is achieved by the identity server generating a token, which it gives to the inviting homeserver. The homeserver will add an ``m.room.third_party_invite`` event into the graph for the room, containing that token.  When the invitee binds the invited third party identifier to a Matrix user ID, the identity server will give the user a list of pending invitations, each containing:  - The room ID to which they were invited  - The token given to the homeserver  - A signature of the token, signed with the identity server\'s private key  - The matrix user ID who invited them to the room  If a token is requested from the identity server, the homeserver will append a ``m.room.third_party_invite`` event to the room.  .. _joining rooms section: `invite-by-user-id-endpoint`_
     * @summary Invite a user to participate in a particular room.
     * @param {string} roomId The room identifier (not alias) to which to invite the user.
     * @param {InlineObject27} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public inviteBy3PID(roomId: string, body: InlineObject27, options?: any) {
        return RoomMembershipApiFp(this.configuration).inviteBy3PID(roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * .. _invite-by-user-id-endpoint:  *Note that there are two forms of this API, which are documented separately. This version of the API requires that the inviter knows the Matrix identifier of the invitee. The other is documented in the* `third party invites section`_.  This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.  Only users currently in a particular room can invite other users to join that room.  If the user was invited to the room, the homeserver will append a ``m.room.member`` event to the room.  .. _third party invites section: `invite-by-third-party-id-endpoint`_
     * @summary Invite a user to participate in a particular room.
     * @param {string} roomId The room identifier (not alias) to which to invite the user.
     * @param {InlineObject28} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public inviteUser(roomId: string, body: InlineObject28, options?: any) {
        return RoomMembershipApiFp(this.configuration).inviteUser(roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * *Note that this API takes either a room ID or alias, unlike* ``/room/{roomId}/join``.  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
     * @summary Start the requesting user participating in a particular room.
     * @param {string} roomIdOrAlias The room identifier or alias to join.
     * @param {Array<string>} [serverName] The servers to attempt to join the room through. One of the servers must be participating in the room.
     * @param {InlineObject12} [thirdPartySigned]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public joinRoom(roomIdOrAlias: string, serverName?: Array<string>, thirdPartySigned?: InlineObject12, options?: any) {
        return RoomMembershipApiFp(this.configuration).joinRoom(roomIdOrAlias, serverName, thirdPartySigned, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * *Note that this API requires a room ID, not alias.* ``/join/{roomIdOrAlias}`` *exists if you have a room alias.*  This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.  After a user has joined a room, the room will appear as an entry in the response of the |/initialSync|_ and |/sync|_ APIs.  If a ``third_party_signed`` was supplied, the homeserver must verify that it matches a pending ``m.room.third_party_invite`` event in the room, and perform key validity checking if required by the event.
     * @summary Start the requesting user participating in a particular room.
     * @param {string} roomId The room identifier (not alias) to join.
     * @param {InlineObject29} [thirdPartySigned]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public joinRoomById(roomId: string, thirdPartySigned?: InlineObject29, options?: any) {
        return RoomMembershipApiFp(this.configuration).joinRoomById(roomId, thirdPartySigned, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kick a user from the room.  The caller must have the required power level in order to perform this operation.  Kicking a user adjusts the target member\'s membership state to be ``leave`` with an optional ``reason``. Like with other membership changes, a user can directly adjust the target member\'s state by making a request to ``/rooms/<room id>/state/m.room.member/<user id>``.
     * @summary Kick a user from the room.
     * @param {string} roomId The room identifier (not alias) from which the user should be kicked.
     * @param {InlineObject30} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public kick(roomId: string, body: InlineObject30, options?: any) {
        return RoomMembershipApiFp(this.configuration).kick(roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API stops a user participating in a particular room.  If the user was already in the room, they will no longer be able to see new events in the room. If the room requires an invite to join, they will need to be re-invited before they can re-join.  If the user was invited to the room, but had not joined, this call serves to reject the invite.  The user will still be allowed to retrieve history from the room which they were previously allowed to see.
     * @summary Stop the requesting user participating in a particular room.
     * @param {string} roomId The room identifier to leave.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public leaveRoom(roomId: string, options?: any) {
        return RoomMembershipApiFp(this.configuration).leaveRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unban a user from the room. This allows them to be invited to the room, and join if they would otherwise be allowed to join according to its join rules.  The caller must have the required power level in order to perform this operation.
     * @summary Unban a user from the room.
     * @param {string} roomId The room identifier (not alias) from which the user should be unbanned.
     * @param {InlineObject35} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomMembershipApi
     */
    public unban(roomId: string, body: InlineObject35, options?: any) {
        return RoomMembershipApiFp(this.configuration).unban(roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoomParticipationApi - axios parameter creator
 * @export
 */
export const RoomParticipationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads a new filter definition to the homeserver. Returns a filter ID that may be used in future requests to restrict which events are returned to the client.
         * @summary Upload a new filter.
         * @param {string} userId The id of the user uploading the filter. The access token must be authorized to make requests for this user id.
         * @param {any} filter The filter to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineFilter: async (userId: string, filter: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling defineFilter.');
            }
            // verify required parameter 'filter' is not null or undefined
            if (filter === null || filter === undefined) {
                throw new RequiredError('filter','Required parameter filter was null or undefined when calling defineFilter.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/filter`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof filter !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(filter !== undefined ? filter : {}) : (filter || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API returns a number of events that happened just before and after the specified event. This allows clients to get the context surrounding an event.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
         * @summary Get events and state around the specified event.
         * @param {string} roomId The room to get events from.
         * @param {string} eventId The event to get context around.
         * @param {number} [limit] The maximum number of events to return. Default: 10.
         * @param {string} [filter] A JSON &#x60;&#x60;RoomEventFilter&#x60;&#x60; to filter the returned events with. The filter is only applied to &#x60;&#x60;events_before&#x60;&#x60;, &#x60;&#x60;events_after&#x60;&#x60;, and &#x60;&#x60;state&#x60;&#x60;. It is not applied to the &#x60;&#x60;event&#x60;&#x60; itself. The filter may be applied before or/and after the &#x60;&#x60;limit&#x60;&#x60; parameter - whichever the homeserver prefers.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventContext: async (roomId: string, eventId: string, limit?: number, filter?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getEventContext.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getEventContext.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/context/{eventId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will listen for new events and return them to the caller. This will block until an event is received, or until the ``timeout`` is reached.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with a ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Listen on the event stream.
         * @param {string} [from] The token to stream from. This token is either from a previous request to this API or from the initial sync API.
         * @param {number} [timeout] The maximum time in milliseconds to wait for an event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (from?: string, timeout?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Download a filter
         * @param {string} userId The user ID to download a filter for.
         * @param {string} filterId The filter ID to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter: async (userId: string, filterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getFilter.');
            }
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId','Required parameter filterId was null or undefined when calling getFilter.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/filter/{filterId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API returns a map of MXIDs to member info objects for members of the room. The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS\'s users must be in the room. This API is primarily for Application Services and should be faster to respond than ``/members`` as it can be implemented more efficiently on the server.
         * @summary Gets the list of currently joined users and their profile data.
         * @param {string} roomId The room to get the members of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoinedMembersByRoom: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getJoinedMembersByRoom.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/joined_members`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of members for this room.
         * @summary Get the m.room.member events for the room.
         * @param {string} roomId The room to get the member events for.
         * @param {string} [at] The point in time (pagination token) to return members for in the room. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API. Defaults to the current state of the room, as determined by the server.
         * @param {'join' | 'invite' | 'leave' | 'ban'} [membership] The kind of membership to filter for. Defaults to no filtering if unspecified. When specified alongside &#x60;&#x60;not_membership&#x60;&#x60;, the two parameters create an \&#39;or\&#39; condition: either the membership *is* the same as &#x60;&#x60;membership&#x60;&#x60; **or** *is not* the same as &#x60;&#x60;not_membership&#x60;&#x60;.
         * @param {'join' | 'invite' | 'leave' | 'ban'} [notMembership] The kind of membership to exclude from the results. Defaults to no filtering if unspecified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersByRoom: async (roomId: string, at?: string, membership?: 'join' | 'invite' | 'leave' | 'ban', notMembership?: 'join' | 'invite' | 'leave' | 'ban', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getMembersByRoom.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/members`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (at !== undefined) {
                localVarQueryParameter['at'] = at;
            }

            if (membership !== undefined) {
                localVarQueryParameter['membership'] = membership;
            }

            if (notMembership !== undefined) {
                localVarQueryParameter['not_membership'] = notMembership;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single event based on ``event_id``. You must have permission to retrieve this event e.g. by being a member in the room for this event.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/rooms/{roomId}/event/{eventId}|_ API or the |/rooms/{roomId}/context/{eventId}|_ API.
         * @summary Get a single event by event ID.
         * @param {string} eventId The event ID to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneEvent: async (eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getOneEvent.');
            }
            const localVarPath = `/_matrix/client/r0/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single event based on ``roomId/eventId``. You must have permission to retrieve this event e.g. by being a member in the room for this event.
         * @summary Get a single event by event ID.
         * @param {string} roomId The ID of the room the event is in.
         * @param {string} eventId The event ID to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneRoomEvent: async (roomId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getOneRoomEvent.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getOneRoomEvent.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/event/{eventId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of message and state events for a room. It uses pagination query parameters to paginate history in the room.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
         * @summary Get a list of events for this room
         * @param {string} roomId The room to get events from.
         * @param {string} from The token to start returning events from. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
         * @param {'b' | 'f'} dir The direction to return events from.
         * @param {string} [to] The token to stop returning events at. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync endpoint, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
         * @param {number} [limit] The maximum number of events to return. Default: 10.
         * @param {string} [filter] A JSON RoomEventFilter to filter returned events with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomEvents: async (roomId: string, from: string, dir: 'b' | 'f', to?: string, limit?: number, filter?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getRoomEvents.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getRoomEvents.');
            }
            // verify required parameter 'dir' is not null or undefined
            if (dir === null || dir === undefined) {
                throw new RequiredError('dir','Required parameter dir was null or undefined when calling getRoomEvents.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/messages`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the state events for the current state of a room.
         * @summary Get all state events in the current state of a room.
         * @param {string} roomId The room to look up the state for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomState: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getRoomState.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/state`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * .. For backwards compatibility with older links... .. _`get-matrix-client-unstable-rooms-roomid-state-eventtype`:  Looks up the contents of a state event in a room. If the user is joined to the room then the state is taken from the current state of the room. If the user has left the room then the state is taken from the state of the room when they left.
         * @summary Get the state identified by the type and key.
         * @param {string} roomId The room to look up the state in.
         * @param {string} eventType The type of state to look up.
         * @param {string} stateKey The key of the state to look up. Defaults to an empty string. When an empty string, the trailing slash on this endpoint is optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomStateWithKey: async (roomId: string, eventType: string, stateKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getRoomStateWithKey.');
            }
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling getRoomStateWithKey.');
            }
            // verify required parameter 'stateKey' is not null or undefined
            if (stateKey === null || stateKey === undefined) {
                throw new RequiredError('stateKey','Required parameter stateKey was null or undefined when calling getRoomStateWithKey.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/state/{eventType}/{stateKey}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"stateKey"}}`, encodeURIComponent(String(stateKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns the full state for this user, with an optional limit on the number of messages per room to return.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with no ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Get the user\'s current state.
         * @param {number} [limit] The maximum number of messages to return for each room.
         * @param {boolean} [archived] Whether to include rooms that the user has left. If &#x60;&#x60;false&#x60;&#x60; then only rooms that the user has been invited to or has joined are included. If set to &#x60;&#x60;true&#x60;&#x60; then rooms that the user has left are included as well. By default this is &#x60;&#x60;false&#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initialSync: async (limit?: number, archived?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/initialSync`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API updates the marker for the given receipt type to the event ID specified.
         * @summary Send a receipt for the given event ID.
         * @param {string} roomId The room in which to send the event.
         * @param {'m.read'} receiptType The type of receipt to send.
         * @param {string} eventId The event ID to acknowledge up to.
         * @param {object} [receipt] Extra receipt information to attach to &#x60;&#x60;content&#x60;&#x60; if any. The server will automatically set the &#x60;&#x60;ts&#x60;&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReceipt: async (roomId: string, receiptType: 'm.read', eventId: string, receipt?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling postReceipt.');
            }
            // verify required parameter 'receiptType' is not null or undefined
            if (receiptType === null || receiptType === undefined) {
                throw new RequiredError('receiptType','Required parameter receiptType was null or undefined when calling postReceipt.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling postReceipt.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/receipt/{receiptType}/{eventId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"receiptType"}}`, encodeURIComponent(String(receiptType)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof receipt !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(receipt !== undefined ? receipt : {}) : (receipt || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Strips all information out of an event which isn\'t critical to the integrity of the server-side representation of the room.  This cannot be undone.  Users may redact their own events, and any user with a power level greater than or equal to the ``redact`` power level of the room may redact events there.
         * @summary Strips all non-integrity-critical information out of an event.
         * @param {string} roomId The room from which to redact the event.
         * @param {string} eventId The ID of the event to redact
         * @param {string} txnId The transaction ID for this event. Clients should generate a unique ID; it will be used by the server to ensure idempotency of requests.
         * @param {InlineObject32} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redactEvent: async (roomId: string, eventId: string, txnId: string, body?: InlineObject32, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling redactEvent.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling redactEvent.');
            }
            // verify required parameter 'txnId' is not null or undefined
            if (txnId === null || txnId === undefined) {
                throw new RequiredError('txnId','Required parameter txnId was null or undefined when calling redactEvent.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/redact/{eventId}/{txnId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a copy of the current state and the most recent messages in a room.  This endpoint was deprecated in r0 of this specification. There is no direct replacement; the relevant information is returned by the |/sync|_ API. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Snapshot the current state of a room and its most recent messages.
         * @param {string} roomId The room to get the data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomInitialSync: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling roomInitialSync.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/initialSync`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to send a message event to a room. Message events allow access to historical events and pagination, making them suited for \"once-off\" activity in a room.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the m. event specification.
         * @summary Send a message event to the given room.
         * @param {string} roomId The room to send the event to.
         * @param {string} eventType The type of event to send.
         * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (roomId: string, eventType: string, txnId: string, body?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling sendMessage.');
            }
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling sendMessage.');
            }
            // verify required parameter 'txnId' is not null or undefined
            if (txnId === null || txnId === undefined) {
                throw new RequiredError('txnId','Required parameter txnId was null or undefined when calling sendMessage.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/send/{eventType}/{txnId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * .. For backwards compatibility with older links... .. _`put-matrix-client-unstable-rooms-roomid-state-eventtype`:  State events can be sent using this endpoint.  These events will be overwritten if ``<room id>``, ``<event type>`` and ``<state key>`` all match.  Requests to this endpoint **cannot use transaction IDs** like other ``PUT`` paths because they cannot be differentiated from the ``state_key``. Furthermore, ``POST`` is unsupported on state paths.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the ``m.`` event specification.  If the event type being sent is ``m.room.canonical_alias`` servers SHOULD ensure that any new aliases being listed in the event are valid per their grammar/syntax and that they point to the room ID where the state event is to be sent. Servers do not validate aliases which are being removed or are already present in the state event.
         * @summary Send a state event to the given room.
         * @param {string} roomId The room to set the state in
         * @param {string} eventType The type of event to send.
         * @param {string} stateKey The state_key for the state to send. Defaults to the empty string. When an empty string, the trailing slash on this endpoint is optional.
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomStateWithKey: async (roomId: string, eventType: string, stateKey: string, body?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling setRoomStateWithKey.');
            }
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling setRoomStateWithKey.');
            }
            // verify required parameter 'stateKey' is not null or undefined
            if (stateKey === null || stateKey === undefined) {
                throw new RequiredError('stateKey','Required parameter stateKey was null or undefined when calling setRoomStateWithKey.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/state/{eventType}/{stateKey}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"stateKey"}}`, encodeURIComponent(String(stateKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This tells the server that the user is typing for the next N milliseconds where N is the value specified in the ``timeout`` key. Alternatively, if ``typing`` is ``false``, it tells the server that the user has stopped typing.
         * @summary Informs the server that the user has started or stopped typing.
         * @param {string} userId The user who has started to type.
         * @param {string} roomId The room in which the user is typing.
         * @param {InlineObject34} typingState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTyping: async (userId: string, roomId: string, typingState: InlineObject34, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setTyping.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling setTyping.');
            }
            // verify required parameter 'typingState' is not null or undefined
            if (typingState === null || typingState === undefined) {
                throw new RequiredError('typingState','Required parameter typingState was null or undefined when calling setTyping.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/typing/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof typingState !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(typingState !== undefined ? typingState : {}) : (typingState || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Synchronise the client\'s state with the latest state on the server. Clients use this API when they first log in to get an initial snapshot of the state on the server, and then continue to call this API to get incremental deltas to the state, and to receive new messages.  *Note*: This endpoint supports lazy-loading. See `Filtering <#filtering>`_ for more information. Lazy-loading members is only supported on a ``StateFilter`` for this endpoint. When lazy-loading is enabled, servers MUST include the syncing user\'s own membership event when they join a room, or when the full state of rooms is requested, to aid discovering the user\'s avatar & displayname.  Like other members, the user\'s own membership event is eligible for being considered redundant by the server. When a sync is ``limited``, the server MUST return membership events for events in the gap (between ``since`` and the start of the returned timeline), regardless as to whether or not they are redundant.  This ensures that joins/leaves and profile changes which occur during the gap are not lost.
         * @summary Synchronise the client\'s state and receive new messages.
         * @param {string} [filter] The ID of a filter created using the filter API or a filter JSON object encoded as a string. The server will detect whether it is an ID or a JSON object by whether the first character is a &#x60;&#x60;\&quot;{\&quot;&#x60;&#x60; open brace. Passing the JSON inline is best suited to one off requests. Creating a filter using the filter API is recommended for clients that reuse the same filter multiple times, for example in long poll requests.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
         * @param {string} [since] A point in time to continue a sync from.
         * @param {boolean} [fullState] Controls whether to include the full state for all rooms the user is a member of.  If this is set to &#x60;&#x60;true&#x60;&#x60;, then all state events will be returned, even if &#x60;&#x60;since&#x60;&#x60; is non-empty. The timeline will still be limited by the &#x60;&#x60;since&#x60;&#x60; parameter. In this case, the &#x60;&#x60;timeout&#x60;&#x60; parameter will be ignored and the query will return immediately, possibly with an empty timeline.  If &#x60;&#x60;false&#x60;&#x60;, and &#x60;&#x60;since&#x60;&#x60; is non-empty, only state which has changed since the point indicated by &#x60;&#x60;since&#x60;&#x60; will be returned.  By default, this is &#x60;&#x60;false&#x60;&#x60;.
         * @param {'offline' | 'online' | 'unavailable'} [setPresence] Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to \&quot;offline\&quot; then the client is not marked as being online when it uses this API. When set to \&quot;unavailable\&quot;, the client is marked as being idle.
         * @param {number} [timeout] The maximum time to wait, in milliseconds, before returning this request. If no events (or other data) become available before this time elapses, the server will return a response with empty fields.  By default, this is &#x60;&#x60;0&#x60;&#x60;, so the server will return immediately even if the response is empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync: async (filter?: string, since?: string, fullState?: boolean, setPresence?: 'offline' | 'online' | 'unavailable', timeout?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/sync`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (fullState !== undefined) {
                localVarQueryParameter['full_state'] = fullState;
            }

            if (setPresence !== undefined) {
                localVarQueryParameter['set_presence'] = setPresence;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomParticipationApi - functional programming interface
 * @export
 */
export const RoomParticipationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Uploads a new filter definition to the homeserver. Returns a filter ID that may be used in future requests to restrict which events are returned to the client.
         * @summary Upload a new filter.
         * @param {string} userId The id of the user uploading the filter. The access token must be authorized to make requests for this user id.
         * @param {any} filter The filter to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineFilter(userId: string, filter: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).defineFilter(userId, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API returns a number of events that happened just before and after the specified event. This allows clients to get the context surrounding an event.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
         * @summary Get events and state around the specified event.
         * @param {string} roomId The room to get events from.
         * @param {string} eventId The event to get context around.
         * @param {number} [limit] The maximum number of events to return. Default: 10.
         * @param {string} [filter] A JSON &#x60;&#x60;RoomEventFilter&#x60;&#x60; to filter the returned events with. The filter is only applied to &#x60;&#x60;events_before&#x60;&#x60;, &#x60;&#x60;events_after&#x60;&#x60;, and &#x60;&#x60;state&#x60;&#x60;. It is not applied to the &#x60;&#x60;event&#x60;&#x60; itself. The filter may be applied before or/and after the &#x60;&#x60;limit&#x60;&#x60; parameter - whichever the homeserver prefers.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventContext(roomId: string, eventId: string, limit?: number, filter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getEventContext(roomId, eventId, limit, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This will listen for new events and return them to the caller. This will block until an event is received, or until the ``timeout`` is reached.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with a ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Listen on the event stream.
         * @param {string} [from] The token to stream from. This token is either from a previous request to this API or from the initial sync API.
         * @param {number} [timeout] The maximum time in milliseconds to wait for an event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(from?: string, timeout?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getEvents(from, timeout, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Download a filter
         * @param {string} userId The user ID to download a filter for.
         * @param {string} filterId The filter ID to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilter(userId: string, filterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getFilter(userId, filterId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API returns a map of MXIDs to member info objects for members of the room. The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS\'s users must be in the room. This API is primarily for Application Services and should be faster to respond than ``/members`` as it can be implemented more efficiently on the server.
         * @summary Gets the list of currently joined users and their profile data.
         * @param {string} roomId The room to get the members of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJoinedMembersByRoom(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getJoinedMembersByRoom(roomId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the list of members for this room.
         * @summary Get the m.room.member events for the room.
         * @param {string} roomId The room to get the member events for.
         * @param {string} [at] The point in time (pagination token) to return members for in the room. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API. Defaults to the current state of the room, as determined by the server.
         * @param {'join' | 'invite' | 'leave' | 'ban'} [membership] The kind of membership to filter for. Defaults to no filtering if unspecified. When specified alongside &#x60;&#x60;not_membership&#x60;&#x60;, the two parameters create an \&#39;or\&#39; condition: either the membership *is* the same as &#x60;&#x60;membership&#x60;&#x60; **or** *is not* the same as &#x60;&#x60;not_membership&#x60;&#x60;.
         * @param {'join' | 'invite' | 'leave' | 'ban'} [notMembership] The kind of membership to exclude from the results. Defaults to no filtering if unspecified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembersByRoom(roomId: string, at?: string, membership?: 'join' | 'invite' | 'leave' | 'ban', notMembership?: 'join' | 'invite' | 'leave' | 'ban', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getMembersByRoom(roomId, at, membership, notMembership, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a single event based on ``event_id``. You must have permission to retrieve this event e.g. by being a member in the room for this event.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/rooms/{roomId}/event/{eventId}|_ API or the |/rooms/{roomId}/context/{eventId}|_ API.
         * @summary Get a single event by event ID.
         * @param {string} eventId The event ID to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneEvent(eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getOneEvent(eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a single event based on ``roomId/eventId``. You must have permission to retrieve this event e.g. by being a member in the room for this event.
         * @summary Get a single event by event ID.
         * @param {string} roomId The ID of the room the event is in.
         * @param {string} eventId The event ID to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneRoomEvent(roomId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getOneRoomEvent(roomId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API returns a list of message and state events for a room. It uses pagination query parameters to paginate history in the room.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
         * @summary Get a list of events for this room
         * @param {string} roomId The room to get events from.
         * @param {string} from The token to start returning events from. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
         * @param {'b' | 'f'} dir The direction to return events from.
         * @param {string} [to] The token to stop returning events at. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync endpoint, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
         * @param {number} [limit] The maximum number of events to return. Default: 10.
         * @param {string} [filter] A JSON RoomEventFilter to filter returned events with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomEvents(roomId: string, from: string, dir: 'b' | 'f', to?: string, limit?: number, filter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getRoomEvents(roomId, from, dir, to, limit, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the state events for the current state of a room.
         * @summary Get all state events in the current state of a room.
         * @param {string} roomId The room to look up the state for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomState(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getRoomState(roomId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * .. For backwards compatibility with older links... .. _`get-matrix-client-unstable-rooms-roomid-state-eventtype`:  Looks up the contents of a state event in a room. If the user is joined to the room then the state is taken from the current state of the room. If the user has left the room then the state is taken from the state of the room when they left.
         * @summary Get the state identified by the type and key.
         * @param {string} roomId The room to look up the state in.
         * @param {string} eventType The type of state to look up.
         * @param {string} stateKey The key of the state to look up. Defaults to an empty string. When an empty string, the trailing slash on this endpoint is optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomStateWithKey(roomId: string, eventType: string, stateKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).getRoomStateWithKey(roomId, eventType, stateKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This returns the full state for this user, with an optional limit on the number of messages per room to return.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with no ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Get the user\'s current state.
         * @param {number} [limit] The maximum number of messages to return for each room.
         * @param {boolean} [archived] Whether to include rooms that the user has left. If &#x60;&#x60;false&#x60;&#x60; then only rooms that the user has been invited to or has joined are included. If set to &#x60;&#x60;true&#x60;&#x60; then rooms that the user has left are included as well. By default this is &#x60;&#x60;false&#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initialSync(limit?: number, archived?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).initialSync(limit, archived, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API updates the marker for the given receipt type to the event ID specified.
         * @summary Send a receipt for the given event ID.
         * @param {string} roomId The room in which to send the event.
         * @param {'m.read'} receiptType The type of receipt to send.
         * @param {string} eventId The event ID to acknowledge up to.
         * @param {object} [receipt] Extra receipt information to attach to &#x60;&#x60;content&#x60;&#x60; if any. The server will automatically set the &#x60;&#x60;ts&#x60;&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReceipt(roomId: string, receiptType: 'm.read', eventId: string, receipt?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).postReceipt(roomId, receiptType, eventId, receipt, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Strips all information out of an event which isn\'t critical to the integrity of the server-side representation of the room.  This cannot be undone.  Users may redact their own events, and any user with a power level greater than or equal to the ``redact`` power level of the room may redact events there.
         * @summary Strips all non-integrity-critical information out of an event.
         * @param {string} roomId The room from which to redact the event.
         * @param {string} eventId The ID of the event to redact
         * @param {string} txnId The transaction ID for this event. Clients should generate a unique ID; it will be used by the server to ensure idempotency of requests.
         * @param {InlineObject32} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redactEvent(roomId: string, eventId: string, txnId: string, body?: InlineObject32, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).redactEvent(roomId, eventId, txnId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a copy of the current state and the most recent messages in a room.  This endpoint was deprecated in r0 of this specification. There is no direct replacement; the relevant information is returned by the |/sync|_ API. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Snapshot the current state of a room and its most recent messages.
         * @param {string} roomId The room to get the data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomInitialSync(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomInfo1>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).roomInitialSync(roomId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint is used to send a message event to a room. Message events allow access to historical events and pagination, making them suited for \"once-off\" activity in a room.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the m. event specification.
         * @summary Send a message event to the given room.
         * @param {string} roomId The room to send the event to.
         * @param {string} eventType The type of event to send.
         * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(roomId: string, eventType: string, txnId: string, body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).sendMessage(roomId, eventType, txnId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * .. For backwards compatibility with older links... .. _`put-matrix-client-unstable-rooms-roomid-state-eventtype`:  State events can be sent using this endpoint.  These events will be overwritten if ``<room id>``, ``<event type>`` and ``<state key>`` all match.  Requests to this endpoint **cannot use transaction IDs** like other ``PUT`` paths because they cannot be differentiated from the ``state_key``. Furthermore, ``POST`` is unsupported on state paths.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the ``m.`` event specification.  If the event type being sent is ``m.room.canonical_alias`` servers SHOULD ensure that any new aliases being listed in the event are valid per their grammar/syntax and that they point to the room ID where the state event is to be sent. Servers do not validate aliases which are being removed or are already present in the state event.
         * @summary Send a state event to the given room.
         * @param {string} roomId The room to set the state in
         * @param {string} eventType The type of event to send.
         * @param {string} stateKey The state_key for the state to send. Defaults to the empty string. When an empty string, the trailing slash on this endpoint is optional.
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoomStateWithKey(roomId: string, eventType: string, stateKey: string, body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).setRoomStateWithKey(roomId, eventType, stateKey, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This tells the server that the user is typing for the next N milliseconds where N is the value specified in the ``timeout`` key. Alternatively, if ``typing`` is ``false``, it tells the server that the user has stopped typing.
         * @summary Informs the server that the user has started or stopped typing.
         * @param {string} userId The user who has started to type.
         * @param {string} roomId The room in which the user is typing.
         * @param {InlineObject34} typingState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTyping(userId: string, roomId: string, typingState: InlineObject34, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).setTyping(userId, roomId, typingState, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Synchronise the client\'s state with the latest state on the server. Clients use this API when they first log in to get an initial snapshot of the state on the server, and then continue to call this API to get incremental deltas to the state, and to receive new messages.  *Note*: This endpoint supports lazy-loading. See `Filtering <#filtering>`_ for more information. Lazy-loading members is only supported on a ``StateFilter`` for this endpoint. When lazy-loading is enabled, servers MUST include the syncing user\'s own membership event when they join a room, or when the full state of rooms is requested, to aid discovering the user\'s avatar & displayname.  Like other members, the user\'s own membership event is eligible for being considered redundant by the server. When a sync is ``limited``, the server MUST return membership events for events in the gap (between ``since`` and the start of the returned timeline), regardless as to whether or not they are redundant.  This ensures that joins/leaves and profile changes which occur during the gap are not lost.
         * @summary Synchronise the client\'s state and receive new messages.
         * @param {string} [filter] The ID of a filter created using the filter API or a filter JSON object encoded as a string. The server will detect whether it is an ID or a JSON object by whether the first character is a &#x60;&#x60;\&quot;{\&quot;&#x60;&#x60; open brace. Passing the JSON inline is best suited to one off requests. Creating a filter using the filter API is recommended for clients that reuse the same filter multiple times, for example in long poll requests.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
         * @param {string} [since] A point in time to continue a sync from.
         * @param {boolean} [fullState] Controls whether to include the full state for all rooms the user is a member of.  If this is set to &#x60;&#x60;true&#x60;&#x60;, then all state events will be returned, even if &#x60;&#x60;since&#x60;&#x60; is non-empty. The timeline will still be limited by the &#x60;&#x60;since&#x60;&#x60; parameter. In this case, the &#x60;&#x60;timeout&#x60;&#x60; parameter will be ignored and the query will return immediately, possibly with an empty timeline.  If &#x60;&#x60;false&#x60;&#x60;, and &#x60;&#x60;since&#x60;&#x60; is non-empty, only state which has changed since the point indicated by &#x60;&#x60;since&#x60;&#x60; will be returned.  By default, this is &#x60;&#x60;false&#x60;&#x60;.
         * @param {'offline' | 'online' | 'unavailable'} [setPresence] Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to \&quot;offline\&quot; then the client is not marked as being online when it uses this API. When set to \&quot;unavailable\&quot;, the client is marked as being idle.
         * @param {number} [timeout] The maximum time to wait, in milliseconds, before returning this request. If no events (or other data) become available before this time elapses, the server will return a response with empty fields.  By default, this is &#x60;&#x60;0&#x60;&#x60;, so the server will return immediately even if the response is empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sync(filter?: string, since?: string, fullState?: boolean, setPresence?: 'offline' | 'online' | 'unavailable', timeout?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await RoomParticipationApiAxiosParamCreator(configuration).sync(filter, since, fullState, setPresence, timeout, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoomParticipationApi - factory interface
 * @export
 */
export const RoomParticipationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Uploads a new filter definition to the homeserver. Returns a filter ID that may be used in future requests to restrict which events are returned to the client.
         * @summary Upload a new filter.
         * @param {string} userId The id of the user uploading the filter. The access token must be authorized to make requests for this user id.
         * @param {any} filter The filter to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineFilter(userId: string, filter: any, options?: any): AxiosPromise<InlineResponse20045> {
            return RoomParticipationApiFp(configuration).defineFilter(userId, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a number of events that happened just before and after the specified event. This allows clients to get the context surrounding an event.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
         * @summary Get events and state around the specified event.
         * @param {string} roomId The room to get events from.
         * @param {string} eventId The event to get context around.
         * @param {number} [limit] The maximum number of events to return. Default: 10.
         * @param {string} [filter] A JSON &#x60;&#x60;RoomEventFilter&#x60;&#x60; to filter the returned events with. The filter is only applied to &#x60;&#x60;events_before&#x60;&#x60;, &#x60;&#x60;events_after&#x60;&#x60;, and &#x60;&#x60;state&#x60;&#x60;. It is not applied to the &#x60;&#x60;event&#x60;&#x60; itself. The filter may be applied before or/and after the &#x60;&#x60;limit&#x60;&#x60; parameter - whichever the homeserver prefers.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventContext(roomId: string, eventId: string, limit?: number, filter?: string, options?: any): AxiosPromise<InlineResponse20037> {
            return RoomParticipationApiFp(configuration).getEventContext(roomId, eventId, limit, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * This will listen for new events and return them to the caller. This will block until an event is received, or until the ``timeout`` is reached.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with a ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Listen on the event stream.
         * @param {string} [from] The token to stream from. This token is either from a previous request to this API or from the initial sync API.
         * @param {number} [timeout] The maximum time in milliseconds to wait for an event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(from?: string, timeout?: number, options?: any): AxiosPromise<InlineResponse20011> {
            return RoomParticipationApiFp(configuration).getEvents(from, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Download a filter
         * @param {string} userId The user ID to download a filter for.
         * @param {string} filterId The filter ID to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter(userId: string, filterId: string, options?: any): AxiosPromise<InlineResponse20046> {
            return RoomParticipationApiFp(configuration).getFilter(userId, filterId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a map of MXIDs to member info objects for members of the room. The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS\'s users must be in the room. This API is primarily for Application Services and should be faster to respond than ``/members`` as it can be implemented more efficiently on the server.
         * @summary Gets the list of currently joined users and their profile data.
         * @param {string} roomId The room to get the members of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoinedMembersByRoom(roomId: string, options?: any): AxiosPromise<InlineResponse20038> {
            return RoomParticipationApiFp(configuration).getJoinedMembersByRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of members for this room.
         * @summary Get the m.room.member events for the room.
         * @param {string} roomId The room to get the member events for.
         * @param {string} [at] The point in time (pagination token) to return members for in the room. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API. Defaults to the current state of the room, as determined by the server.
         * @param {'join' | 'invite' | 'leave' | 'ban'} [membership] The kind of membership to filter for. Defaults to no filtering if unspecified. When specified alongside &#x60;&#x60;not_membership&#x60;&#x60;, the two parameters create an \&#39;or\&#39; condition: either the membership *is* the same as &#x60;&#x60;membership&#x60;&#x60; **or** *is not* the same as &#x60;&#x60;not_membership&#x60;&#x60;.
         * @param {'join' | 'invite' | 'leave' | 'ban'} [notMembership] The kind of membership to exclude from the results. Defaults to no filtering if unspecified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersByRoom(roomId: string, at?: string, membership?: 'join' | 'invite' | 'leave' | 'ban', notMembership?: 'join' | 'invite' | 'leave' | 'ban', options?: any): AxiosPromise<InlineResponse20039> {
            return RoomParticipationApiFp(configuration).getMembersByRoom(roomId, at, membership, notMembership, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single event based on ``event_id``. You must have permission to retrieve this event e.g. by being a member in the room for this event.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/rooms/{roomId}/event/{eventId}|_ API or the |/rooms/{roomId}/context/{eventId}|_ API.
         * @summary Get a single event by event ID.
         * @param {string} eventId The event ID to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneEvent(eventId: string, options?: any): AxiosPromise<InlineResponse20012> {
            return RoomParticipationApiFp(configuration).getOneEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single event based on ``roomId/eventId``. You must have permission to retrieve this event e.g. by being a member in the room for this event.
         * @summary Get a single event by event ID.
         * @param {string} roomId The ID of the room the event is in.
         * @param {string} eventId The event ID to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneRoomEvent(roomId: string, eventId: string, options?: any): AxiosPromise<InlineResponse20012> {
            return RoomParticipationApiFp(configuration).getOneRoomEvent(roomId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of message and state events for a room. It uses pagination query parameters to paginate history in the room.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
         * @summary Get a list of events for this room
         * @param {string} roomId The room to get events from.
         * @param {string} from The token to start returning events from. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
         * @param {'b' | 'f'} dir The direction to return events from.
         * @param {string} [to] The token to stop returning events at. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync endpoint, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
         * @param {number} [limit] The maximum number of events to return. Default: 10.
         * @param {string} [filter] A JSON RoomEventFilter to filter returned events with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomEvents(roomId: string, from: string, dir: 'b' | 'f', to?: string, limit?: number, filter?: string, options?: any): AxiosPromise<InlineResponse20040> {
            return RoomParticipationApiFp(configuration).getRoomEvents(roomId, from, dir, to, limit, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the state events for the current state of a room.
         * @summary Get all state events in the current state of a room.
         * @param {string} roomId The room to look up the state for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomState(roomId: string, options?: any): AxiosPromise<Array<object>> {
            return RoomParticipationApiFp(configuration).getRoomState(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * .. For backwards compatibility with older links... .. _`get-matrix-client-unstable-rooms-roomid-state-eventtype`:  Looks up the contents of a state event in a room. If the user is joined to the room then the state is taken from the current state of the room. If the user has left the room then the state is taken from the state of the room when they left.
         * @summary Get the state identified by the type and key.
         * @param {string} roomId The room to look up the state in.
         * @param {string} eventType The type of state to look up.
         * @param {string} stateKey The key of the state to look up. Defaults to an empty string. When an empty string, the trailing slash on this endpoint is optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomStateWithKey(roomId: string, eventType: string, stateKey: string, options?: any): AxiosPromise<object> {
            return RoomParticipationApiFp(configuration).getRoomStateWithKey(roomId, eventType, stateKey, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns the full state for this user, with an optional limit on the number of messages per room to return.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with no ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Get the user\'s current state.
         * @param {number} [limit] The maximum number of messages to return for each room.
         * @param {boolean} [archived] Whether to include rooms that the user has left. If &#x60;&#x60;false&#x60;&#x60; then only rooms that the user has been invited to or has joined are included. If set to &#x60;&#x60;true&#x60;&#x60; then rooms that the user has left are included as well. By default this is &#x60;&#x60;false&#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initialSync(limit?: number, archived?: boolean, options?: any): AxiosPromise<InlineResponse20013> {
            return RoomParticipationApiFp(configuration).initialSync(limit, archived, options).then((request) => request(axios, basePath));
        },
        /**
         * This API updates the marker for the given receipt type to the event ID specified.
         * @summary Send a receipt for the given event ID.
         * @param {string} roomId The room in which to send the event.
         * @param {'m.read'} receiptType The type of receipt to send.
         * @param {string} eventId The event ID to acknowledge up to.
         * @param {object} [receipt] Extra receipt information to attach to &#x60;&#x60;content&#x60;&#x60; if any. The server will automatically set the &#x60;&#x60;ts&#x60;&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReceipt(roomId: string, receiptType: 'm.read', eventId: string, receipt?: object, options?: any): AxiosPromise<object> {
            return RoomParticipationApiFp(configuration).postReceipt(roomId, receiptType, eventId, receipt, options).then((request) => request(axios, basePath));
        },
        /**
         * Strips all information out of an event which isn\'t critical to the integrity of the server-side representation of the room.  This cannot be undone.  Users may redact their own events, and any user with a power level greater than or equal to the ``redact`` power level of the room may redact events there.
         * @summary Strips all non-integrity-critical information out of an event.
         * @param {string} roomId The room from which to redact the event.
         * @param {string} eventId The ID of the event to redact
         * @param {string} txnId The transaction ID for this event. Clients should generate a unique ID; it will be used by the server to ensure idempotency of requests.
         * @param {InlineObject32} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redactEvent(roomId: string, eventId: string, txnId: string, body?: InlineObject32, options?: any): AxiosPromise<InlineResponse20041> {
            return RoomParticipationApiFp(configuration).redactEvent(roomId, eventId, txnId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a copy of the current state and the most recent messages in a room.  This endpoint was deprecated in r0 of this specification. There is no direct replacement; the relevant information is returned by the |/sync|_ API. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
         * @summary Snapshot the current state of a room and its most recent messages.
         * @param {string} roomId The room to get the data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomInitialSync(roomId: string, options?: any): AxiosPromise<RoomInfo1> {
            return RoomParticipationApiFp(configuration).roomInitialSync(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to send a message event to a room. Message events allow access to historical events and pagination, making them suited for \"once-off\" activity in a room.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the m. event specification.
         * @summary Send a message event to the given room.
         * @param {string} roomId The room to send the event to.
         * @param {string} eventType The type of event to send.
         * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(roomId: string, eventType: string, txnId: string, body?: object, options?: any): AxiosPromise<InlineResponse20042> {
            return RoomParticipationApiFp(configuration).sendMessage(roomId, eventType, txnId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * .. For backwards compatibility with older links... .. _`put-matrix-client-unstable-rooms-roomid-state-eventtype`:  State events can be sent using this endpoint.  These events will be overwritten if ``<room id>``, ``<event type>`` and ``<state key>`` all match.  Requests to this endpoint **cannot use transaction IDs** like other ``PUT`` paths because they cannot be differentiated from the ``state_key``. Furthermore, ``POST`` is unsupported on state paths.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the ``m.`` event specification.  If the event type being sent is ``m.room.canonical_alias`` servers SHOULD ensure that any new aliases being listed in the event are valid per their grammar/syntax and that they point to the room ID where the state event is to be sent. Servers do not validate aliases which are being removed or are already present in the state event.
         * @summary Send a state event to the given room.
         * @param {string} roomId The room to set the state in
         * @param {string} eventType The type of event to send.
         * @param {string} stateKey The state_key for the state to send. Defaults to the empty string. When an empty string, the trailing slash on this endpoint is optional.
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomStateWithKey(roomId: string, eventType: string, stateKey: string, body?: object, options?: any): AxiosPromise<InlineResponse20042> {
            return RoomParticipationApiFp(configuration).setRoomStateWithKey(roomId, eventType, stateKey, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This tells the server that the user is typing for the next N milliseconds where N is the value specified in the ``timeout`` key. Alternatively, if ``typing`` is ``false``, it tells the server that the user has stopped typing.
         * @summary Informs the server that the user has started or stopped typing.
         * @param {string} userId The user who has started to type.
         * @param {string} roomId The room in which the user is typing.
         * @param {InlineObject34} typingState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTyping(userId: string, roomId: string, typingState: InlineObject34, options?: any): AxiosPromise<object> {
            return RoomParticipationApiFp(configuration).setTyping(userId, roomId, typingState, options).then((request) => request(axios, basePath));
        },
        /**
         * Synchronise the client\'s state with the latest state on the server. Clients use this API when they first log in to get an initial snapshot of the state on the server, and then continue to call this API to get incremental deltas to the state, and to receive new messages.  *Note*: This endpoint supports lazy-loading. See `Filtering <#filtering>`_ for more information. Lazy-loading members is only supported on a ``StateFilter`` for this endpoint. When lazy-loading is enabled, servers MUST include the syncing user\'s own membership event when they join a room, or when the full state of rooms is requested, to aid discovering the user\'s avatar & displayname.  Like other members, the user\'s own membership event is eligible for being considered redundant by the server. When a sync is ``limited``, the server MUST return membership events for events in the gap (between ``since`` and the start of the returned timeline), regardless as to whether or not they are redundant.  This ensures that joins/leaves and profile changes which occur during the gap are not lost.
         * @summary Synchronise the client\'s state and receive new messages.
         * @param {string} [filter] The ID of a filter created using the filter API or a filter JSON object encoded as a string. The server will detect whether it is an ID or a JSON object by whether the first character is a &#x60;&#x60;\&quot;{\&quot;&#x60;&#x60; open brace. Passing the JSON inline is best suited to one off requests. Creating a filter using the filter API is recommended for clients that reuse the same filter multiple times, for example in long poll requests.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
         * @param {string} [since] A point in time to continue a sync from.
         * @param {boolean} [fullState] Controls whether to include the full state for all rooms the user is a member of.  If this is set to &#x60;&#x60;true&#x60;&#x60;, then all state events will be returned, even if &#x60;&#x60;since&#x60;&#x60; is non-empty. The timeline will still be limited by the &#x60;&#x60;since&#x60;&#x60; parameter. In this case, the &#x60;&#x60;timeout&#x60;&#x60; parameter will be ignored and the query will return immediately, possibly with an empty timeline.  If &#x60;&#x60;false&#x60;&#x60;, and &#x60;&#x60;since&#x60;&#x60; is non-empty, only state which has changed since the point indicated by &#x60;&#x60;since&#x60;&#x60; will be returned.  By default, this is &#x60;&#x60;false&#x60;&#x60;.
         * @param {'offline' | 'online' | 'unavailable'} [setPresence] Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to \&quot;offline\&quot; then the client is not marked as being online when it uses this API. When set to \&quot;unavailable\&quot;, the client is marked as being idle.
         * @param {number} [timeout] The maximum time to wait, in milliseconds, before returning this request. If no events (or other data) become available before this time elapses, the server will return a response with empty fields.  By default, this is &#x60;&#x60;0&#x60;&#x60;, so the server will return immediately even if the response is empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync(filter?: string, since?: string, fullState?: boolean, setPresence?: 'offline' | 'online' | 'unavailable', timeout?: number, options?: any): AxiosPromise<InlineResponse20044> {
            return RoomParticipationApiFp(configuration).sync(filter, since, fullState, setPresence, timeout, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomParticipationApi - object-oriented interface
 * @export
 * @class RoomParticipationApi
 * @extends {BaseAPI}
 */
export class RoomParticipationApi extends BaseAPI {
    /**
     * Uploads a new filter definition to the homeserver. Returns a filter ID that may be used in future requests to restrict which events are returned to the client.
     * @summary Upload a new filter.
     * @param {string} userId The id of the user uploading the filter. The access token must be authorized to make requests for this user id.
     * @param {any} filter The filter to upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public defineFilter(userId: string, filter: any, options?: any) {
        return RoomParticipationApiFp(this.configuration).defineFilter(userId, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a number of events that happened just before and after the specified event. This allows clients to get the context surrounding an event.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
     * @summary Get events and state around the specified event.
     * @param {string} roomId The room to get events from.
     * @param {string} eventId The event to get context around.
     * @param {number} [limit] The maximum number of events to return. Default: 10.
     * @param {string} [filter] A JSON &#x60;&#x60;RoomEventFilter&#x60;&#x60; to filter the returned events with. The filter is only applied to &#x60;&#x60;events_before&#x60;&#x60;, &#x60;&#x60;events_after&#x60;&#x60;, and &#x60;&#x60;state&#x60;&#x60;. It is not applied to the &#x60;&#x60;event&#x60;&#x60; itself. The filter may be applied before or/and after the &#x60;&#x60;limit&#x60;&#x60; parameter - whichever the homeserver prefers.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getEventContext(roomId: string, eventId: string, limit?: number, filter?: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getEventContext(roomId, eventId, limit, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will listen for new events and return them to the caller. This will block until an event is received, or until the ``timeout`` is reached.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with a ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
     * @summary Listen on the event stream.
     * @param {string} [from] The token to stream from. This token is either from a previous request to this API or from the initial sync API.
     * @param {number} [timeout] The maximum time in milliseconds to wait for an event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getEvents(from?: string, timeout?: number, options?: any) {
        return RoomParticipationApiFp(this.configuration).getEvents(from, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Download a filter
     * @param {string} userId The user ID to download a filter for.
     * @param {string} filterId The filter ID to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getFilter(userId: string, filterId: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getFilter(userId, filterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a map of MXIDs to member info objects for members of the room. The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS\'s users must be in the room. This API is primarily for Application Services and should be faster to respond than ``/members`` as it can be implemented more efficiently on the server.
     * @summary Gets the list of currently joined users and their profile data.
     * @param {string} roomId The room to get the members of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getJoinedMembersByRoom(roomId: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getJoinedMembersByRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of members for this room.
     * @summary Get the m.room.member events for the room.
     * @param {string} roomId The room to get the member events for.
     * @param {string} [at] The point in time (pagination token) to return members for in the room. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API. Defaults to the current state of the room, as determined by the server.
     * @param {'join' | 'invite' | 'leave' | 'ban'} [membership] The kind of membership to filter for. Defaults to no filtering if unspecified. When specified alongside &#x60;&#x60;not_membership&#x60;&#x60;, the two parameters create an \&#39;or\&#39; condition: either the membership *is* the same as &#x60;&#x60;membership&#x60;&#x60; **or** *is not* the same as &#x60;&#x60;not_membership&#x60;&#x60;.
     * @param {'join' | 'invite' | 'leave' | 'ban'} [notMembership] The kind of membership to exclude from the results. Defaults to no filtering if unspecified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getMembersByRoom(roomId: string, at?: string, membership?: 'join' | 'invite' | 'leave' | 'ban', notMembership?: 'join' | 'invite' | 'leave' | 'ban', options?: any) {
        return RoomParticipationApiFp(this.configuration).getMembersByRoom(roomId, at, membership, notMembership, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single event based on ``event_id``. You must have permission to retrieve this event e.g. by being a member in the room for this event.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/rooms/{roomId}/event/{eventId}|_ API or the |/rooms/{roomId}/context/{eventId}|_ API.
     * @summary Get a single event by event ID.
     * @param {string} eventId The event ID to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getOneEvent(eventId: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getOneEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single event based on ``roomId/eventId``. You must have permission to retrieve this event e.g. by being a member in the room for this event.
     * @summary Get a single event by event ID.
     * @param {string} roomId The ID of the room the event is in.
     * @param {string} eventId The event ID to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getOneRoomEvent(roomId: string, eventId: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getOneRoomEvent(roomId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of message and state events for a room. It uses pagination query parameters to paginate history in the room.  *Note*: This endpoint supports lazy-loading of room member events. See `Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
     * @summary Get a list of events for this room
     * @param {string} roomId The room to get events from.
     * @param {string} from The token to start returning events from. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync API, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
     * @param {'b' | 'f'} dir The direction to return events from.
     * @param {string} [to] The token to stop returning events at. This token can be obtained from a &#x60;&#x60;prev_batch&#x60;&#x60; token returned for each room by the sync endpoint, or from a &#x60;&#x60;start&#x60;&#x60; or &#x60;&#x60;end&#x60;&#x60; token returned by a previous request to this endpoint.
     * @param {number} [limit] The maximum number of events to return. Default: 10.
     * @param {string} [filter] A JSON RoomEventFilter to filter returned events with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getRoomEvents(roomId: string, from: string, dir: 'b' | 'f', to?: string, limit?: number, filter?: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getRoomEvents(roomId, from, dir, to, limit, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the state events for the current state of a room.
     * @summary Get all state events in the current state of a room.
     * @param {string} roomId The room to look up the state for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getRoomState(roomId: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getRoomState(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * .. For backwards compatibility with older links... .. _`get-matrix-client-unstable-rooms-roomid-state-eventtype`:  Looks up the contents of a state event in a room. If the user is joined to the room then the state is taken from the current state of the room. If the user has left the room then the state is taken from the state of the room when they left.
     * @summary Get the state identified by the type and key.
     * @param {string} roomId The room to look up the state in.
     * @param {string} eventType The type of state to look up.
     * @param {string} stateKey The key of the state to look up. Defaults to an empty string. When an empty string, the trailing slash on this endpoint is optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public getRoomStateWithKey(roomId: string, eventType: string, stateKey: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).getRoomStateWithKey(roomId, eventType, stateKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the full state for this user, with an optional limit on the number of messages per room to return.  This endpoint was deprecated in r0 of this specification. Clients should instead call the |/sync|_ API with no ``since`` parameter. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
     * @summary Get the user\'s current state.
     * @param {number} [limit] The maximum number of messages to return for each room.
     * @param {boolean} [archived] Whether to include rooms that the user has left. If &#x60;&#x60;false&#x60;&#x60; then only rooms that the user has been invited to or has joined are included. If set to &#x60;&#x60;true&#x60;&#x60; then rooms that the user has left are included as well. By default this is &#x60;&#x60;false&#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public initialSync(limit?: number, archived?: boolean, options?: any) {
        return RoomParticipationApiFp(this.configuration).initialSync(limit, archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates the marker for the given receipt type to the event ID specified.
     * @summary Send a receipt for the given event ID.
     * @param {string} roomId The room in which to send the event.
     * @param {'m.read'} receiptType The type of receipt to send.
     * @param {string} eventId The event ID to acknowledge up to.
     * @param {object} [receipt] Extra receipt information to attach to &#x60;&#x60;content&#x60;&#x60; if any. The server will automatically set the &#x60;&#x60;ts&#x60;&#x60; field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public postReceipt(roomId: string, receiptType: 'm.read', eventId: string, receipt?: object, options?: any) {
        return RoomParticipationApiFp(this.configuration).postReceipt(roomId, receiptType, eventId, receipt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Strips all information out of an event which isn\'t critical to the integrity of the server-side representation of the room.  This cannot be undone.  Users may redact their own events, and any user with a power level greater than or equal to the ``redact`` power level of the room may redact events there.
     * @summary Strips all non-integrity-critical information out of an event.
     * @param {string} roomId The room from which to redact the event.
     * @param {string} eventId The ID of the event to redact
     * @param {string} txnId The transaction ID for this event. Clients should generate a unique ID; it will be used by the server to ensure idempotency of requests.
     * @param {InlineObject32} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public redactEvent(roomId: string, eventId: string, txnId: string, body?: InlineObject32, options?: any) {
        return RoomParticipationApiFp(this.configuration).redactEvent(roomId, eventId, txnId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a copy of the current state and the most recent messages in a room.  This endpoint was deprecated in r0 of this specification. There is no direct replacement; the relevant information is returned by the |/sync|_ API. See the `migration guide <https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
     * @summary Snapshot the current state of a room and its most recent messages.
     * @param {string} roomId The room to get the data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public roomInitialSync(roomId: string, options?: any) {
        return RoomParticipationApiFp(this.configuration).roomInitialSync(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to send a message event to a room. Message events allow access to historical events and pagination, making them suited for \"once-off\" activity in a room.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the m. event specification.
     * @summary Send a message event to the given room.
     * @param {string} roomId The room to send the event to.
     * @param {string} eventType The type of event to send.
     * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public sendMessage(roomId: string, eventType: string, txnId: string, body?: object, options?: any) {
        return RoomParticipationApiFp(this.configuration).sendMessage(roomId, eventType, txnId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * .. For backwards compatibility with older links... .. _`put-matrix-client-unstable-rooms-roomid-state-eventtype`:  State events can be sent using this endpoint.  These events will be overwritten if ``<room id>``, ``<event type>`` and ``<state key>`` all match.  Requests to this endpoint **cannot use transaction IDs** like other ``PUT`` paths because they cannot be differentiated from the ``state_key``. Furthermore, ``POST`` is unsupported on state paths.  The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See `Room Events`_ for the ``m.`` event specification.  If the event type being sent is ``m.room.canonical_alias`` servers SHOULD ensure that any new aliases being listed in the event are valid per their grammar/syntax and that they point to the room ID where the state event is to be sent. Servers do not validate aliases which are being removed or are already present in the state event.
     * @summary Send a state event to the given room.
     * @param {string} roomId The room to set the state in
     * @param {string} eventType The type of event to send.
     * @param {string} stateKey The state_key for the state to send. Defaults to the empty string. When an empty string, the trailing slash on this endpoint is optional.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public setRoomStateWithKey(roomId: string, eventType: string, stateKey: string, body?: object, options?: any) {
        return RoomParticipationApiFp(this.configuration).setRoomStateWithKey(roomId, eventType, stateKey, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This tells the server that the user is typing for the next N milliseconds where N is the value specified in the ``timeout`` key. Alternatively, if ``typing`` is ``false``, it tells the server that the user has stopped typing.
     * @summary Informs the server that the user has started or stopped typing.
     * @param {string} userId The user who has started to type.
     * @param {string} roomId The room in which the user is typing.
     * @param {InlineObject34} typingState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public setTyping(userId: string, roomId: string, typingState: InlineObject34, options?: any) {
        return RoomParticipationApiFp(this.configuration).setTyping(userId, roomId, typingState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Synchronise the client\'s state with the latest state on the server. Clients use this API when they first log in to get an initial snapshot of the state on the server, and then continue to call this API to get incremental deltas to the state, and to receive new messages.  *Note*: This endpoint supports lazy-loading. See `Filtering <#filtering>`_ for more information. Lazy-loading members is only supported on a ``StateFilter`` for this endpoint. When lazy-loading is enabled, servers MUST include the syncing user\'s own membership event when they join a room, or when the full state of rooms is requested, to aid discovering the user\'s avatar & displayname.  Like other members, the user\'s own membership event is eligible for being considered redundant by the server. When a sync is ``limited``, the server MUST return membership events for events in the gap (between ``since`` and the start of the returned timeline), regardless as to whether or not they are redundant.  This ensures that joins/leaves and profile changes which occur during the gap are not lost.
     * @summary Synchronise the client\'s state and receive new messages.
     * @param {string} [filter] The ID of a filter created using the filter API or a filter JSON object encoded as a string. The server will detect whether it is an ID or a JSON object by whether the first character is a &#x60;&#x60;\&quot;{\&quot;&#x60;&#x60; open brace. Passing the JSON inline is best suited to one off requests. Creating a filter using the filter API is recommended for clients that reuse the same filter multiple times, for example in long poll requests.  See &#x60;Filtering &lt;#filtering&gt;&#x60;_ for more information.
     * @param {string} [since] A point in time to continue a sync from.
     * @param {boolean} [fullState] Controls whether to include the full state for all rooms the user is a member of.  If this is set to &#x60;&#x60;true&#x60;&#x60;, then all state events will be returned, even if &#x60;&#x60;since&#x60;&#x60; is non-empty. The timeline will still be limited by the &#x60;&#x60;since&#x60;&#x60; parameter. In this case, the &#x60;&#x60;timeout&#x60;&#x60; parameter will be ignored and the query will return immediately, possibly with an empty timeline.  If &#x60;&#x60;false&#x60;&#x60;, and &#x60;&#x60;since&#x60;&#x60; is non-empty, only state which has changed since the point indicated by &#x60;&#x60;since&#x60;&#x60; will be returned.  By default, this is &#x60;&#x60;false&#x60;&#x60;.
     * @param {'offline' | 'online' | 'unavailable'} [setPresence] Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to \&quot;offline\&quot; then the client is not marked as being online when it uses this API. When set to \&quot;unavailable\&quot;, the client is marked as being idle.
     * @param {number} [timeout] The maximum time to wait, in milliseconds, before returning this request. If no events (or other data) become available before this time elapses, the server will return a response with empty fields.  By default, this is &#x60;&#x60;0&#x60;&#x60;, so the server will return immediately even if the response is empty.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomParticipationApi
     */
    public sync(filter?: string, since?: string, fullState?: boolean, setPresence?: 'offline' | 'online' | 'unavailable', timeout?: number, options?: any) {
        return RoomParticipationApiFp(this.configuration).sync(filter, since, fullState, setPresence, timeout, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoomUpgradesApi - axios parameter creator
 * @export
 */
export const RoomUpgradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upgrades the given room to a particular room version.
         * @summary Upgrades a room to a new room version.
         * @param {string} roomId The ID of the room to upgrade.
         * @param {InlineObject36} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeRoom: async (roomId: string, body: InlineObject36, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling upgradeRoom.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling upgradeRoom.');
            }
            const localVarPath = `/_matrix/client/r0/rooms/{roomId}/upgrade`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomUpgradesApi - functional programming interface
 * @export
 */
export const RoomUpgradesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Upgrades the given room to a particular room version.
         * @summary Upgrades a room to a new room version.
         * @param {string} roomId The ID of the room to upgrade.
         * @param {InlineObject36} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeRoom(roomId: string, body: InlineObject36, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await RoomUpgradesApiAxiosParamCreator(configuration).upgradeRoom(roomId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoomUpgradesApi - factory interface
 * @export
 */
export const RoomUpgradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Upgrades the given room to a particular room version.
         * @summary Upgrades a room to a new room version.
         * @param {string} roomId The ID of the room to upgrade.
         * @param {InlineObject36} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeRoom(roomId: string, body: InlineObject36, options?: any): AxiosPromise<InlineResponse20043> {
            return RoomUpgradesApiFp(configuration).upgradeRoom(roomId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomUpgradesApi - object-oriented interface
 * @export
 * @class RoomUpgradesApi
 * @extends {BaseAPI}
 */
export class RoomUpgradesApi extends BaseAPI {
    /**
     * Upgrades the given room to a particular room version.
     * @summary Upgrades a room to a new room version.
     * @param {string} roomId The ID of the room to upgrade.
     * @param {InlineObject36} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomUpgradesApi
     */
    public upgradeRoom(roomId: string, body: InlineObject36, options?: any) {
        return RoomUpgradesApiFp(this.configuration).upgradeRoom(roomId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a full text search across different categories.
         * @summary Perform a server-side search.
         * @param {string} [nextBatch] The point to return events from. If given, this should be a &#x60;&#x60;next_batch&#x60;&#x60; result from a previous call to this endpoint.
         * @param {InlineObject37} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (nextBatch?: string, body?: InlineObject37, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (nextBatch !== undefined) {
                localVarQueryParameter['next_batch'] = nextBatch;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Performs a full text search across different categories.
         * @summary Perform a server-side search.
         * @param {string} [nextBatch] The point to return events from. If given, this should be a &#x60;&#x60;next_batch&#x60;&#x60; result from a previous call to this endpoint.
         * @param {InlineObject37} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(nextBatch?: string, body?: InlineObject37, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Results>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).search(nextBatch, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Performs a full text search across different categories.
         * @summary Perform a server-side search.
         * @param {string} [nextBatch] The point to return events from. If given, this should be a &#x60;&#x60;next_batch&#x60;&#x60; result from a previous call to this endpoint.
         * @param {InlineObject37} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(nextBatch?: string, body?: InlineObject37, options?: any): AxiosPromise<Results> {
            return SearchApiFp(configuration).search(nextBatch, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Performs a full text search across different categories.
     * @summary Perform a server-side search.
     * @param {string} [nextBatch] The point to return events from. If given, this should be a &#x60;&#x60;next_batch&#x60;&#x60; result from a previous call to this endpoint.
     * @param {InlineObject37} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(nextBatch?: string, body?: InlineObject37, options?: any) {
        return SearchApiFp(this.configuration).search(nextBatch, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SendToDeviceMessagingApi - axios parameter creator
 * @export
 */
export const SendToDeviceMessagingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to send send-to-device events to a set of client devices.
         * @summary Send an event to a given set of devices.
         * @param {string} eventType The type of event to send.
         * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
         * @param {Body} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToDevice: async (eventType: string, txnId: string, body: Body, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling sendToDevice.');
            }
            // verify required parameter 'txnId' is not null or undefined
            if (txnId === null || txnId === undefined) {
                throw new RequiredError('txnId','Required parameter txnId was null or undefined when calling sendToDevice.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendToDevice.');
            }
            const localVarPath = `/_matrix/client/r0/sendToDevice/{eventType}/{txnId}`
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"txnId"}}`, encodeURIComponent(String(txnId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SendToDeviceMessagingApi - functional programming interface
 * @export
 */
export const SendToDeviceMessagingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to send send-to-device events to a set of client devices.
         * @summary Send an event to a given set of devices.
         * @param {string} eventType The type of event to send.
         * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
         * @param {Body} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendToDevice(eventType: string, txnId: string, body: Body, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SendToDeviceMessagingApiAxiosParamCreator(configuration).sendToDevice(eventType, txnId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SendToDeviceMessagingApi - factory interface
 * @export
 */
export const SendToDeviceMessagingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint is used to send send-to-device events to a set of client devices.
         * @summary Send an event to a given set of devices.
         * @param {string} eventType The type of event to send.
         * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
         * @param {Body} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToDevice(eventType: string, txnId: string, body: Body, options?: any): AxiosPromise<void> {
            return SendToDeviceMessagingApiFp(configuration).sendToDevice(eventType, txnId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SendToDeviceMessagingApi - object-oriented interface
 * @export
 * @class SendToDeviceMessagingApi
 * @extends {BaseAPI}
 */
export class SendToDeviceMessagingApi extends BaseAPI {
    /**
     * This endpoint is used to send send-to-device events to a set of client devices.
     * @summary Send an event to a given set of devices.
     * @param {string} eventType The type of event to send.
     * @param {string} txnId The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.
     * @param {Body} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendToDeviceMessagingApi
     */
    public sendToDevice(eventType: string, txnId: string, body: Body, options?: any) {
        return SendToDeviceMessagingApiFp(this.configuration).sendToDevice(eventType, txnId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ServerAdministrationApi - axios parameter creator
 * @export
 */
export const ServerAdministrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the versions of the specification supported by the server.  Values will take the form ``rX.Y.Z``.  Only the latest ``Z`` value will be reported for each supported ``X.Y`` value. i.e. if the server implements ``r0.0.0``, ``r0.0.1``, and ``r1.2.0``, it will report ``r0.0.1`` and ``r1.2.0``.  The server may additionally advertise experimental features it supports through ``unstable_features``. These features should be namespaced and may optionally include version information within their name if desired. Features listed here are not for optionally toggling parts of the Matrix specification and should only be used to advertise support for a feature which has not yet landed in the spec. For example, a feature currently undergoing the proposal process may appear here and eventually be taken off this list once the feature lands in the spec and the server deems it reasonable to do so. Servers may wish to keep advertising features here after they\'ve been released into the spec to give clients a chance to upgrade appropriately. Additionally, clients should avoid using unstable features in their stable releases.
         * @summary Gets the versions of the specification supported by the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/versions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets discovery information about the domain. The file may include additional keys, which MUST follow the Java package naming convention, e.g. ``com.example.myapp.property``. This ensures property names are suitably namespaced for each application and reduces the risk of clashes.  Note that this endpoint is not necessarily handled by the homeserver, but by another webserver, to be used for discovering the homeserver URL.
         * @summary Gets Matrix server discovery information about the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWellknown: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/matrix/client`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information about a particular user.  This API may be restricted to only be called by the user being looked up, or by a server admin. Server-local administrator privileges are not specified in this document.
         * @summary Gets information about a particular user.
         * @param {string} userId The user to look up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhoIs: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getWhoIs.');
            }
            const localVarPath = `/_matrix/client/r0/admin/whois/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerAdministrationApi - functional programming interface
 * @export
 */
export const ServerAdministrationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets the versions of the specification supported by the server.  Values will take the form ``rX.Y.Z``.  Only the latest ``Z`` value will be reported for each supported ``X.Y`` value. i.e. if the server implements ``r0.0.0``, ``r0.0.1``, and ``r1.2.0``, it will report ``r0.0.1`` and ``r1.2.0``.  The server may additionally advertise experimental features it supports through ``unstable_features``. These features should be namespaced and may optionally include version information within their name if desired. Features listed here are not for optionally toggling parts of the Matrix specification and should only be used to advertise support for a feature which has not yet landed in the spec. For example, a feature currently undergoing the proposal process may appear here and eventually be taken off this list once the feature lands in the spec and the server deems it reasonable to do so. Servers may wish to keep advertising features here after they\'ve been released into the spec to give clients a chance to upgrade appropriately. Additionally, clients should avoid using unstable features in their stable releases.
         * @summary Gets the versions of the specification supported by the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await ServerAdministrationApiAxiosParamCreator(configuration).getVersions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets discovery information about the domain. The file may include additional keys, which MUST follow the Java package naming convention, e.g. ``com.example.myapp.property``. This ensures property names are suitably namespaced for each application and reduces the risk of clashes.  Note that this endpoint is not necessarily handled by the homeserver, but by another webserver, to be used for discovering the homeserver URL.
         * @summary Gets Matrix server discovery information about the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWellknown(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await ServerAdministrationApiAxiosParamCreator(configuration).getWellknown(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets information about a particular user.  This API may be restricted to only be called by the user being looked up, or by a server admin. Server-local administrator privileges are not specified in this document.
         * @summary Gets information about a particular user.
         * @param {string} userId The user to look up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWhoIs(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await ServerAdministrationApiAxiosParamCreator(configuration).getWhoIs(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ServerAdministrationApi - factory interface
 * @export
 */
export const ServerAdministrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets the versions of the specification supported by the server.  Values will take the form ``rX.Y.Z``.  Only the latest ``Z`` value will be reported for each supported ``X.Y`` value. i.e. if the server implements ``r0.0.0``, ``r0.0.1``, and ``r1.2.0``, it will report ``r0.0.1`` and ``r1.2.0``.  The server may additionally advertise experimental features it supports through ``unstable_features``. These features should be namespaced and may optionally include version information within their name if desired. Features listed here are not for optionally toggling parts of the Matrix specification and should only be used to advertise support for a feature which has not yet landed in the spec. For example, a feature currently undergoing the proposal process may appear here and eventually be taken off this list once the feature lands in the spec and the server deems it reasonable to do so. Servers may wish to keep advertising features here after they\'ve been released into the spec to give clients a chance to upgrade appropriately. Additionally, clients should avoid using unstable features in their stable releases.
         * @summary Gets the versions of the specification supported by the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): AxiosPromise<InlineResponse20051> {
            return ServerAdministrationApiFp(configuration).getVersions(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets discovery information about the domain. The file may include additional keys, which MUST follow the Java package naming convention, e.g. ``com.example.myapp.property``. This ensures property names are suitably namespaced for each application and reduces the risk of clashes.  Note that this endpoint is not necessarily handled by the homeserver, but by another webserver, to be used for discovering the homeserver URL.
         * @summary Gets Matrix server discovery information about the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWellknown(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return ServerAdministrationApiFp(configuration).getWellknown(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information about a particular user.  This API may be restricted to only be called by the user being looked up, or by a server admin. Server-local administrator privileges are not specified in this document.
         * @summary Gets information about a particular user.
         * @param {string} userId The user to look up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhoIs(userId: string, options?: any): AxiosPromise<InlineResponse2005> {
            return ServerAdministrationApiFp(configuration).getWhoIs(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerAdministrationApi - object-oriented interface
 * @export
 * @class ServerAdministrationApi
 * @extends {BaseAPI}
 */
export class ServerAdministrationApi extends BaseAPI {
    /**
     * Gets the versions of the specification supported by the server.  Values will take the form ``rX.Y.Z``.  Only the latest ``Z`` value will be reported for each supported ``X.Y`` value. i.e. if the server implements ``r0.0.0``, ``r0.0.1``, and ``r1.2.0``, it will report ``r0.0.1`` and ``r1.2.0``.  The server may additionally advertise experimental features it supports through ``unstable_features``. These features should be namespaced and may optionally include version information within their name if desired. Features listed here are not for optionally toggling parts of the Matrix specification and should only be used to advertise support for a feature which has not yet landed in the spec. For example, a feature currently undergoing the proposal process may appear here and eventually be taken off this list once the feature lands in the spec and the server deems it reasonable to do so. Servers may wish to keep advertising features here after they\'ve been released into the spec to give clients a chance to upgrade appropriately. Additionally, clients should avoid using unstable features in their stable releases.
     * @summary Gets the versions of the specification supported by the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAdministrationApi
     */
    public getVersions(options?: any) {
        return ServerAdministrationApiFp(this.configuration).getVersions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets discovery information about the domain. The file may include additional keys, which MUST follow the Java package naming convention, e.g. ``com.example.myapp.property``. This ensures property names are suitably namespaced for each application and reduces the risk of clashes.  Note that this endpoint is not necessarily handled by the homeserver, but by another webserver, to be used for discovering the homeserver URL.
     * @summary Gets Matrix server discovery information about the domain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAdministrationApi
     */
    public getWellknown(options?: any) {
        return ServerAdministrationApiFp(this.configuration).getWellknown(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information about a particular user.  This API may be restricted to only be called by the user being looked up, or by a server admin. Server-local administrator privileges are not specified in this document.
     * @summary Gets information about a particular user.
     * @param {string} userId The user to look up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAdministrationApi
     */
    public getWhoIs(userId: string, options?: any) {
        return ServerAdministrationApiFp(this.configuration).getWhoIs(userId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SessionManagementApi - axios parameter creator
 * @export
 */
export const SessionManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the homeserver\'s supported login types to authenticate users. Clients should pick one of these and supply it as the ``type`` when logging in.
         * @summary Get the supported login types to authenticate users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginFlows: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.
         * @summary Authenticates the user.
         * @param {InlineObject16} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (body?: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates an existing access token, so that it can no longer be used for authorization. The device associated with the access token is also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.
         * @summary Invalidates a user access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates all access tokens for a user, so that they can no longer be used for authorization. This includes the access token that made this request. All devices for the user are also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.  This endpoint does not require UI authorization because UI authorization is designed to protect against attacks where the someone gets hold of a single access token then takes over the account. This endpoint invalidates all access tokens for the user, including the token used in the request, and therefore the attacker is unable to take over the account in this way.
         * @summary Invalidates all access tokens for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/logout/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionManagementApi - functional programming interface
 * @export
 */
export const SessionManagementApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets the homeserver\'s supported login types to authenticate users. Clients should pick one of these and supply it as the ``type`` when logging in.
         * @summary Get the supported login types to authenticate users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginFlows(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await SessionManagementApiAxiosParamCreator(configuration).getLoginFlows(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.
         * @summary Authenticates the user.
         * @param {InlineObject16} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(body?: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await SessionManagementApiAxiosParamCreator(configuration).login(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalidates an existing access token, so that it can no longer be used for authorization. The device associated with the access token is also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.
         * @summary Invalidates a user access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await SessionManagementApiAxiosParamCreator(configuration).logout(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invalidates all access tokens for a user, so that they can no longer be used for authorization. This includes the access token that made this request. All devices for the user are also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.  This endpoint does not require UI authorization because UI authorization is designed to protect against attacks where the someone gets hold of a single access token then takes over the account. This endpoint invalidates all access tokens for the user, including the token used in the request, and therefore the attacker is unable to take over the account in this way.
         * @summary Invalidates all access tokens for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await SessionManagementApiAxiosParamCreator(configuration).logoutAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SessionManagementApi - factory interface
 * @export
 */
export const SessionManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets the homeserver\'s supported login types to authenticate users. Clients should pick one of these and supply it as the ``type`` when logging in.
         * @summary Get the supported login types to authenticate users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginFlows(options?: any): AxiosPromise<InlineResponse20020> {
            return SessionManagementApiFp(configuration).getLoginFlows(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.
         * @summary Authenticates the user.
         * @param {InlineObject16} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: InlineObject16, options?: any): AxiosPromise<InlineResponse20021> {
            return SessionManagementApiFp(configuration).login(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates an existing access token, so that it can no longer be used for authorization. The device associated with the access token is also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.
         * @summary Invalidates a user access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<object> {
            return SessionManagementApiFp(configuration).logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates all access tokens for a user, so that they can no longer be used for authorization. This includes the access token that made this request. All devices for the user are also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.  This endpoint does not require UI authorization because UI authorization is designed to protect against attacks where the someone gets hold of a single access token then takes over the account. This endpoint invalidates all access tokens for the user, including the token used in the request, and therefore the attacker is unable to take over the account in this way.
         * @summary Invalidates all access tokens for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAll(options?: any): AxiosPromise<object> {
            return SessionManagementApiFp(configuration).logoutAll(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionManagementApi - object-oriented interface
 * @export
 * @class SessionManagementApi
 * @extends {BaseAPI}
 */
export class SessionManagementApi extends BaseAPI {
    /**
     * Gets the homeserver\'s supported login types to authenticate users. Clients should pick one of these and supply it as the ``type`` when logging in.
     * @summary Get the supported login types to authenticate users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionManagementApi
     */
    public getLoginFlows(options?: any) {
        return SessionManagementApiFp(this.configuration).getLoginFlows(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.
     * @summary Authenticates the user.
     * @param {InlineObject16} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionManagementApi
     */
    public login(body?: InlineObject16, options?: any) {
        return SessionManagementApiFp(this.configuration).login(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates an existing access token, so that it can no longer be used for authorization. The device associated with the access token is also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.
     * @summary Invalidates a user access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionManagementApi
     */
    public logout(options?: any) {
        return SessionManagementApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates all access tokens for a user, so that they can no longer be used for authorization. This includes the access token that made this request. All devices for the user are also deleted. `Device keys <#device-keys>`_ for the device are deleted alongside the device.  This endpoint does not require UI authorization because UI authorization is designed to protect against attacks where the someone gets hold of a single access token then takes over the account. This endpoint invalidates all access tokens for the user, including the token used in the request, and therefore the attacker is unable to take over the account in this way.
     * @summary Invalidates all access tokens for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionManagementApi
     */
    public logoutAll(options?: any) {
        return SessionManagementApiFp(this.configuration).logoutAll(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserDataApi - axios parameter creator
 * @export
 */
export const UserDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Binds a 3PID to the user\'s account through the specified identity server.  Homeservers should not prevent this request from succeeding if another user has bound the 3PID. Homeservers should simply proxy any errors received by the identity server to the caller.  Homeservers should track successful binds so they can be unbound later.
         * @summary Binds a 3PID to the user\'s account through an Identity Service.
         * @param {InlineObject1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bind3PID: async (body?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/3pid/bind`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the password for an account on this homeserver.  This API endpoint uses the `User-Interactive Authentication API`_ to ensure the user changing the password is actually the owner of the account.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided. The homeserver SHOULD NOT revoke the access token provided in the request. Whether other access tokens for the user are revoked depends on the request parameters.
         * @summary Changes a user\'s password.
         * @param {InlineObject5} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (body?: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks to see if a username is available, and valid, for the server.  The server should check to ensure that, at the time of the request, the username requested is available for use. This includes verifying that an application service has not claimed the username and that the username fits the server\'s desired requirements (for example, a server could dictate that it does not permit usernames with underscores).  Matrix clients may wish to use this API prior to attempting registration, however the clients must also be aware that using this API does not normally reserve the username. This can mean that the username becomes unavailable between checking its availability and attempting to register it.
         * @summary Checks to see if a username is available on the server.
         * @param {string} username The username to check the availability of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsernameAvailability: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling checkUsernameAvailability.');
            }
            const localVarPath = `/_matrix/client/r0/register/available`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate the user\'s account, removing all ability for the user to login again.  This API endpoint uses the `User-Interactive Authentication API`_.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Deactivate a user\'s account.
         * @param {InlineObject4} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateAccount: async (body?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/deactivate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a third party identifier from the user\'s account. This might not cause an unbind of the identifier from the identity server.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Deletes a third party identifier from the user\'s account
         * @param {InlineObject2} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3pidFromAccount: async (body?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/3pid/delete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from the room.
         * @summary Remove a tag from the room.
         * @param {string} userId The id of the user to remove a tag for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to remove a tag from.
         * @param {string} tag The tag to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomTag: async (userId: string, roomId: string, tag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteRoomTag.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling deleteRoomTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling deleteRoomTag.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags/{tag}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of the third party identifiers that the homeserver has associated with the user\'s account.  This is *not* the same as the list of third party identifiers bound to the user\'s Matrix ID in identity servers.  Identifiers in this list may be used by the homeserver as, for example, identifiers that it will accept to reset the user\'s account password.
         * @summary Gets a list of a user\'s third party identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount3PIDs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/3pid`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get some account_data for the client. This config is only visible to the user that set the account_data.
         * @summary Get some account_data for the user.
         * @param {string} userId The ID of the user to get account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountData: async (userId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getAccountData.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getAccountData.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/account_data/{type}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get some account_data for the client on a given room. This config is only visible to the user that set the account_data.
         * @summary Get some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to get account_data for.
         * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDataPerRoom: async (userId: string, roomId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getAccountDataPerRoom.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getAccountDataPerRoom.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getAccountDataPerRoom.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/rooms/{roomId}/account_data/{type}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s avatar URL. This API may be used to fetch the user\'s own avatar URL or to query the URL of other users; either locally or on remote homeservers.
         * @summary Get the user\'s avatar URL.
         * @param {string} userId The user whose avatar URL to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatarUrl: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getAvatarUrl.');
            }
            const localVarPath = `/_matrix/client/r0/profile/{userId}/avatar_url`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s display name. This API may be used to fetch the user\'s own displayname or to query the name of other users; either locally or on remote homeservers.
         * @summary Get the user\'s display name.
         * @param {string} userId The user whose display name to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayName: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getDisplayName.');
            }
            const localVarPath = `/_matrix/client/r0/profile/{userId}/displayname`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the tags set by a user on a room.
         * @summary List the tags for a room.
         * @param {string} userId The id of the user to get tags for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to get tags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomTags: async (userId: string, roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getRoomTags.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling getRoomTags.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information about the owner of a given access token.  Note that, as with the rest of the Client-Server API, Application Services may masquerade as users within their namespace by giving a ``user_id`` query parameter. In this situation, the server should verify that the given ``user_id`` is registered by the appservice, and return it in the response body.
         * @summary Gets information about the owner of an access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenOwner: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/whoami`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the combined profile information for this user. This API may be used to fetch the user\'s own profile information or other users; either locally or on remote homeservers. This API may return keys which are not limited to ``displayname`` or ``avatar_url``.
         * @summary Get this user\'s profile information.
         * @param {string} userId The user whose profile information to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserProfile.');
            }
            const localVarPath = `/_matrix/client/r0/profile/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds contact information to the user\'s account.  This endpoint is deprecated in favour of the more specific ``/3pid/add`` and ``/3pid/bind`` endpoints.  .. Note::    Previously this endpoint supported a ``bind`` parameter. This parameter    has been removed, making this endpoint behave as though it was ``false``.    This results in this endpoint being an equivalent to ``/3pid/bind`` rather    than dual-purpose.
         * @summary Adds contact information to the user\'s account.
         * @param {InlineObject} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post3PIDs: async (body?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/3pid`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_, except in the cases where a guest account is being registered.  Register for an account on this homeserver.  There are two kinds of user account:  - `user` accounts. These accounts may use the full API described in this specification.  - `guest` accounts. These accounts may have limited permissions and may not be supported by all servers.  If registration is successful, this endpoint will issue an access token the client can use to authorize itself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The server SHOULD register an account with a User ID based on the ``username`` provided, if any. Note that the grammar of Matrix User ID localparts is restricted, so the server MUST either map the provided ``username`` onto a ``user_id`` in a logical manner, or reject ``username``\\s which do not comply to the grammar, with ``M_INVALID_USERNAME``.  Matrix clients MUST NOT assume that localpart of the registered ``user_id`` matches the provided ``username``.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.  When registering a guest account, all parameters in the request body with the exception of ``initial_device_display_name`` MUST BE ignored by the server. The server MUST pick a ``device_id`` for the account regardless of input.  Any user ID returned by this API must conform to the grammar given in the `Matrix specification <../appendices.html#user-identifiers>`_.
         * @summary Register for an account on this homeserver.
         * @param {'guest' | 'user'} [kind] The kind of account to register. Defaults to &#x60;&#x60;user&#x60;&#x60;.
         * @param {InlineObject25} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (kind?: 'guest' | 'user', body?: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/register`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a search for users. The homeserver may determine which subset of users are searched, however the homeserver MUST at a minimum consider the users the requesting user shares a room with and those who reside in public rooms (known to the homeserver). The search MUST consider local users to the homeserver, and SHOULD query remote users as part of the search.  The search is performed case-insensitively on user IDs and display names preferably using a collation determined based upon the ``Accept-Language`` header provided in the request, if present.
         * @summary Searches the user directory.
         * @param {InlineObject39} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserDirectory: async (body?: InlineObject39, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/user_directory/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set some account_data for the client. This config is only visible to the user that set the account_data. The config will be synced to clients in the top-level ``account_data``.
         * @summary Set some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
         * @param {object} content The content of the account_data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountData: async (userId: string, type: string, content: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setAccountData.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling setAccountData.');
            }
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling setAccountData.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/account_data/{type}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof content !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(content !== undefined ? content : {}) : (content || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set some account_data for the client on a given room. This config is only visible to the user that set the account_data. The config will be synced to clients in the per-room ``account_data``.
         * @summary Set some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to set account_data on.
         * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
         * @param {object} content The content of the account_data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountDataPerRoom: async (userId: string, roomId: string, type: string, content: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setAccountDataPerRoom.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling setAccountDataPerRoom.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling setAccountDataPerRoom.');
            }
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling setAccountDataPerRoom.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/rooms/{roomId}/account_data/{type}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof content !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(content !== undefined ? content : {}) : (content || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API sets the given user\'s avatar URL. You must have permission to set this user\'s avatar URL, e.g. you need to have their ``access_token``.
         * @summary Set the user\'s avatar URL.
         * @param {string} userId The user whose avatar URL to set.
         * @param {InlineObject18} avatarUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAvatarUrl: async (userId: string, avatarUrl: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setAvatarUrl.');
            }
            // verify required parameter 'avatarUrl' is not null or undefined
            if (avatarUrl === null || avatarUrl === undefined) {
                throw new RequiredError('avatarUrl','Required parameter avatarUrl was null or undefined when calling setAvatarUrl.');
            }
            const localVarPath = `/_matrix/client/r0/profile/{userId}/avatar_url`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof avatarUrl !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(avatarUrl !== undefined ? avatarUrl : {}) : (avatarUrl || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API sets the given user\'s display name. You must have permission to set this user\'s display name, e.g. you need to have their ``access_token``.
         * @summary Set the user\'s display name.
         * @param {string} userId The user whose display name to set.
         * @param {InlineObject19} displayName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDisplayName: async (userId: string, displayName: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setDisplayName.');
            }
            // verify required parameter 'displayName' is not null or undefined
            if (displayName === null || displayName === undefined) {
                throw new RequiredError('displayName','Required parameter displayName was null or undefined when calling setDisplayName.');
            }
            const localVarPath = `/_matrix/client/r0/profile/{userId}/displayname`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof displayName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(displayName !== undefined ? displayName : {}) : (displayName || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to the room.
         * @summary Add a tag to a room.
         * @param {string} userId The id of the user to add a tag for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to add a tag to.
         * @param {string} tag The tag to add.
         * @param {InlineObject38} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomTag: async (userId: string, roomId: string, tag: string, body: InlineObject38, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setRoomTag.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling setRoomTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling setRoomTag.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setRoomTag.');
            }
            const localVarPath = `/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags/{tag}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a user\'s third party identifier from the provided identity server without removing it from the homeserver.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Removes a user\'s third party identifier from an identity server.
         * @param {InlineObject3} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbind3pidFromAccount: async (body?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/account/3pid/unbind`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserDataApi - functional programming interface
 * @export
 */
export const UserDataApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Binds a 3PID to the user\'s account through the specified identity server.  Homeservers should not prevent this request from succeeding if another user has bound the 3PID. Homeservers should simply proxy any errors received by the identity server to the caller.  Homeservers should track successful binds so they can be unbound later.
         * @summary Binds a 3PID to the user\'s account through an Identity Service.
         * @param {InlineObject1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bind3PID(body?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).bind3PID(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes the password for an account on this homeserver.  This API endpoint uses the `User-Interactive Authentication API`_ to ensure the user changing the password is actually the owner of the account.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided. The homeserver SHOULD NOT revoke the access token provided in the request. Whether other access tokens for the user are revoked depends on the request parameters.
         * @summary Changes a user\'s password.
         * @param {InlineObject5} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(body?: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).changePassword(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Checks to see if a username is available, and valid, for the server.  The server should check to ensure that, at the time of the request, the username requested is available for use. This includes verifying that an application service has not claimed the username and that the username fits the server\'s desired requirements (for example, a server could dictate that it does not permit usernames with underscores).  Matrix clients may wish to use this API prior to attempting registration, however the clients must also be aware that using this API does not normally reserve the username. This can mean that the username becomes unavailable between checking its availability and attempting to register it.
         * @summary Checks to see if a username is available on the server.
         * @param {string} username The username to check the availability of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUsernameAvailability(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).checkUsernameAvailability(username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deactivate the user\'s account, removing all ability for the user to login again.  This API endpoint uses the `User-Interactive Authentication API`_.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Deactivate a user\'s account.
         * @param {InlineObject4} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateAccount(body?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).deactivateAccount(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes a third party identifier from the user\'s account. This might not cause an unbind of the identifier from the identity server.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Deletes a third party identifier from the user\'s account
         * @param {InlineObject2} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3pidFromAccount(body?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).delete3pidFromAccount(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a tag from the room.
         * @summary Remove a tag from the room.
         * @param {string} userId The id of the user to remove a tag for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to remove a tag from.
         * @param {string} tag The tag to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoomTag(userId: string, roomId: string, tag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).deleteRoomTag(userId, roomId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of the third party identifiers that the homeserver has associated with the user\'s account.  This is *not* the same as the list of third party identifiers bound to the user\'s Matrix ID in identity servers.  Identifiers in this list may be used by the homeserver as, for example, identifiers that it will accept to reset the user\'s account password.
         * @summary Gets a list of a user\'s third party identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount3PIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getAccount3PIDs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get some account_data for the client. This config is only visible to the user that set the account_data.
         * @summary Get some account_data for the user.
         * @param {string} userId The ID of the user to get account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountData(userId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getAccountData(userId, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get some account_data for the client on a given room. This config is only visible to the user that set the account_data.
         * @summary Get some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to get account_data for.
         * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountDataPerRoom(userId: string, roomId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getAccountDataPerRoom(userId, roomId, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the user\'s avatar URL. This API may be used to fetch the user\'s own avatar URL or to query the URL of other users; either locally or on remote homeservers.
         * @summary Get the user\'s avatar URL.
         * @param {string} userId The user whose avatar URL to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvatarUrl(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getAvatarUrl(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the user\'s display name. This API may be used to fetch the user\'s own displayname or to query the name of other users; either locally or on remote homeservers.
         * @summary Get the user\'s display name.
         * @param {string} userId The user whose display name to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplayName(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getDisplayName(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the tags set by a user on a room.
         * @summary List the tags for a room.
         * @param {string} userId The id of the user to get tags for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to get tags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomTags(userId: string, roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getRoomTags(userId, roomId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets information about the owner of a given access token.  Note that, as with the rest of the Client-Server API, Application Services may masquerade as users within their namespace by giving a ``user_id`` query parameter. In this situation, the server should verify that the given ``user_id`` is registered by the appservice, and return it in the response body.
         * @summary Gets information about the owner of an access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenOwner(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getTokenOwner(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the combined profile information for this user. This API may be used to fetch the user\'s own profile information or other users; either locally or on remote homeservers. This API may return keys which are not limited to ``displayname`` or ``avatar_url``.
         * @summary Get this user\'s profile information.
         * @param {string} userId The user whose profile information to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).getUserProfile(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds contact information to the user\'s account.  This endpoint is deprecated in favour of the more specific ``/3pid/add`` and ``/3pid/bind`` endpoints.  .. Note::    Previously this endpoint supported a ``bind`` parameter. This parameter    has been removed, making this endpoint behave as though it was ``false``.    This results in this endpoint being an equivalent to ``/3pid/bind`` rather    than dual-purpose.
         * @summary Adds contact information to the user\'s account.
         * @param {InlineObject} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post3PIDs(body?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).post3PIDs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_, except in the cases where a guest account is being registered.  Register for an account on this homeserver.  There are two kinds of user account:  - `user` accounts. These accounts may use the full API described in this specification.  - `guest` accounts. These accounts may have limited permissions and may not be supported by all servers.  If registration is successful, this endpoint will issue an access token the client can use to authorize itself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The server SHOULD register an account with a User ID based on the ``username`` provided, if any. Note that the grammar of Matrix User ID localparts is restricted, so the server MUST either map the provided ``username`` onto a ``user_id`` in a logical manner, or reject ``username``\\s which do not comply to the grammar, with ``M_INVALID_USERNAME``.  Matrix clients MUST NOT assume that localpart of the registered ``user_id`` matches the provided ``username``.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.  When registering a guest account, all parameters in the request body with the exception of ``initial_device_display_name`` MUST BE ignored by the server. The server MUST pick a ``device_id`` for the account regardless of input.  Any user ID returned by this API must conform to the grammar given in the `Matrix specification <../appendices.html#user-identifiers>`_.
         * @summary Register for an account on this homeserver.
         * @param {'guest' | 'user'} [kind] The kind of account to register. Defaults to &#x60;&#x60;user&#x60;&#x60;.
         * @param {InlineObject25} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(kind?: 'guest' | 'user', body?: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).register(kind, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Performs a search for users. The homeserver may determine which subset of users are searched, however the homeserver MUST at a minimum consider the users the requesting user shares a room with and those who reside in public rooms (known to the homeserver). The search MUST consider local users to the homeserver, and SHOULD query remote users as part of the search.  The search is performed case-insensitively on user IDs and display names preferably using a collation determined based upon the ``Accept-Language`` header provided in the request, if present.
         * @summary Searches the user directory.
         * @param {InlineObject39} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUserDirectory(body?: InlineObject39, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).searchUserDirectory(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set some account_data for the client. This config is only visible to the user that set the account_data. The config will be synced to clients in the top-level ``account_data``.
         * @summary Set some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
         * @param {object} content The content of the account_data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAccountData(userId: string, type: string, content: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).setAccountData(userId, type, content, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set some account_data for the client on a given room. This config is only visible to the user that set the account_data. The config will be synced to clients in the per-room ``account_data``.
         * @summary Set some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to set account_data on.
         * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
         * @param {object} content The content of the account_data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAccountDataPerRoom(userId: string, roomId: string, type: string, content: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).setAccountDataPerRoom(userId, roomId, type, content, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API sets the given user\'s avatar URL. You must have permission to set this user\'s avatar URL, e.g. you need to have their ``access_token``.
         * @summary Set the user\'s avatar URL.
         * @param {string} userId The user whose avatar URL to set.
         * @param {InlineObject18} avatarUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAvatarUrl(userId: string, avatarUrl: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).setAvatarUrl(userId, avatarUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API sets the given user\'s display name. You must have permission to set this user\'s display name, e.g. you need to have their ``access_token``.
         * @summary Set the user\'s display name.
         * @param {string} userId The user whose display name to set.
         * @param {InlineObject19} displayName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDisplayName(userId: string, displayName: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).setDisplayName(userId, displayName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a tag to the room.
         * @summary Add a tag to a room.
         * @param {string} userId The id of the user to add a tag for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to add a tag to.
         * @param {string} tag The tag to add.
         * @param {InlineObject38} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoomTag(userId: string, roomId: string, tag: string, body: InlineObject38, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).setRoomTag(userId, roomId, tag, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes a user\'s third party identifier from the provided identity server without removing it from the homeserver.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Removes a user\'s third party identifier from an identity server.
         * @param {InlineObject3} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbind3pidFromAccount(body?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await UserDataApiAxiosParamCreator(configuration).unbind3pidFromAccount(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserDataApi - factory interface
 * @export
 */
export const UserDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Binds a 3PID to the user\'s account through the specified identity server.  Homeservers should not prevent this request from succeeding if another user has bound the 3PID. Homeservers should simply proxy any errors received by the identity server to the caller.  Homeservers should track successful binds so they can be unbound later.
         * @summary Binds a 3PID to the user\'s account through an Identity Service.
         * @param {InlineObject1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bind3PID(body?: InlineObject1, options?: any): AxiosPromise<void> {
            return UserDataApiFp(configuration).bind3PID(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the password for an account on this homeserver.  This API endpoint uses the `User-Interactive Authentication API`_ to ensure the user changing the password is actually the owner of the account.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided. The homeserver SHOULD NOT revoke the access token provided in the request. Whether other access tokens for the user are revoked depends on the request parameters.
         * @summary Changes a user\'s password.
         * @param {InlineObject5} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body?: InlineObject5, options?: any): AxiosPromise<object> {
            return UserDataApiFp(configuration).changePassword(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks to see if a username is available, and valid, for the server.  The server should check to ensure that, at the time of the request, the username requested is available for use. This includes verifying that an application service has not claimed the username and that the username fits the server\'s desired requirements (for example, a server could dictate that it does not permit usernames with underscores).  Matrix clients may wish to use this API prior to attempting registration, however the clients must also be aware that using this API does not normally reserve the username. This can mean that the username becomes unavailable between checking its availability and attempting to register it.
         * @summary Checks to see if a username is available on the server.
         * @param {string} username The username to check the availability of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsernameAvailability(username: string, options?: any): AxiosPromise<InlineResponse20035> {
            return UserDataApiFp(configuration).checkUsernameAvailability(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate the user\'s account, removing all ability for the user to login again.  This API endpoint uses the `User-Interactive Authentication API`_.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Deactivate a user\'s account.
         * @param {InlineObject4} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateAccount(body?: InlineObject4, options?: any): AxiosPromise<InlineResponse2003> {
            return UserDataApiFp(configuration).deactivateAccount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a third party identifier from the user\'s account. This might not cause an unbind of the identifier from the identity server.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Deletes a third party identifier from the user\'s account
         * @param {InlineObject2} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3pidFromAccount(body?: InlineObject2, options?: any): AxiosPromise<InlineResponse2001> {
            return UserDataApiFp(configuration).delete3pidFromAccount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from the room.
         * @summary Remove a tag from the room.
         * @param {string} userId The id of the user to remove a tag for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to remove a tag from.
         * @param {string} tag The tag to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomTag(userId: string, roomId: string, tag: string, options?: any): AxiosPromise<object> {
            return UserDataApiFp(configuration).deleteRoomTag(userId, roomId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of the third party identifiers that the homeserver has associated with the user\'s account.  This is *not* the same as the list of third party identifiers bound to the user\'s Matrix ID in identity servers.  Identifiers in this list may be used by the homeserver as, for example, identifiers that it will accept to reset the user\'s account password.
         * @summary Gets a list of a user\'s third party identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount3PIDs(options?: any): AxiosPromise<InlineResponse200> {
            return UserDataApiFp(configuration).getAccount3PIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Get some account_data for the client. This config is only visible to the user that set the account_data.
         * @summary Get some account_data for the user.
         * @param {string} userId The ID of the user to get account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountData(userId: string, type: string, options?: any): AxiosPromise<object> {
            return UserDataApiFp(configuration).getAccountData(userId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get some account_data for the client on a given room. This config is only visible to the user that set the account_data.
         * @summary Get some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to get account_data for.
         * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDataPerRoom(userId: string, roomId: string, type: string, options?: any): AxiosPromise<object> {
            return UserDataApiFp(configuration).getAccountDataPerRoom(userId, roomId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s avatar URL. This API may be used to fetch the user\'s own avatar URL or to query the URL of other users; either locally or on remote homeservers.
         * @summary Get the user\'s avatar URL.
         * @param {string} userId The user whose avatar URL to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatarUrl(userId: string, options?: any): AxiosPromise<InlineResponse20025> {
            return UserDataApiFp(configuration).getAvatarUrl(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s display name. This API may be used to fetch the user\'s own displayname or to query the name of other users; either locally or on remote homeservers.
         * @summary Get the user\'s display name.
         * @param {string} userId The user whose display name to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayName(userId: string, options?: any): AxiosPromise<InlineResponse20026> {
            return UserDataApiFp(configuration).getDisplayName(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the tags set by a user on a room.
         * @summary List the tags for a room.
         * @param {string} userId The id of the user to get tags for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to get tags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomTags(userId: string, roomId: string, options?: any): AxiosPromise<InlineResponse20048> {
            return UserDataApiFp(configuration).getRoomTags(userId, roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information about the owner of a given access token.  Note that, as with the rest of the Client-Server API, Application Services may masquerade as users within their namespace by giving a ``user_id`` query parameter. In this situation, the server should verify that the given ``user_id`` is registered by the appservice, and return it in the response body.
         * @summary Gets information about the owner of an access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenOwner(options?: any): AxiosPromise<InlineResponse2004> {
            return UserDataApiFp(configuration).getTokenOwner(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the combined profile information for this user. This API may be used to fetch the user\'s own profile information or other users; either locally or on remote homeservers. This API may return keys which are not limited to ``displayname`` or ``avatar_url``.
         * @summary Get this user\'s profile information.
         * @param {string} userId The user whose profile information to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile(userId: string, options?: any): AxiosPromise<InlineResponse20024> {
            return UserDataApiFp(configuration).getUserProfile(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds contact information to the user\'s account.  This endpoint is deprecated in favour of the more specific ``/3pid/add`` and ``/3pid/bind`` endpoints.  .. Note::    Previously this endpoint supported a ``bind`` parameter. This parameter    has been removed, making this endpoint behave as though it was ``false``.    This results in this endpoint being an equivalent to ``/3pid/bind`` rather    than dual-purpose.
         * @summary Adds contact information to the user\'s account.
         * @param {InlineObject} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post3PIDs(body?: InlineObject, options?: any): AxiosPromise<void> {
            return UserDataApiFp(configuration).post3PIDs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint uses the `User-Interactive Authentication API`_, except in the cases where a guest account is being registered.  Register for an account on this homeserver.  There are two kinds of user account:  - `user` accounts. These accounts may use the full API described in this specification.  - `guest` accounts. These accounts may have limited permissions and may not be supported by all servers.  If registration is successful, this endpoint will issue an access token the client can use to authorize itself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The server SHOULD register an account with a User ID based on the ``username`` provided, if any. Note that the grammar of Matrix User ID localparts is restricted, so the server MUST either map the provided ``username`` onto a ``user_id`` in a logical manner, or reject ``username``\\s which do not comply to the grammar, with ``M_INVALID_USERNAME``.  Matrix clients MUST NOT assume that localpart of the registered ``user_id`` matches the provided ``username``.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.  When registering a guest account, all parameters in the request body with the exception of ``initial_device_display_name`` MUST BE ignored by the server. The server MUST pick a ``device_id`` for the account regardless of input.  Any user ID returned by this API must conform to the grammar given in the `Matrix specification <../appendices.html#user-identifiers>`_.
         * @summary Register for an account on this homeserver.
         * @param {'guest' | 'user'} [kind] The kind of account to register. Defaults to &#x60;&#x60;user&#x60;&#x60;.
         * @param {InlineObject25} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(kind?: 'guest' | 'user', body?: InlineObject25, options?: any): AxiosPromise<InlineResponse20034> {
            return UserDataApiFp(configuration).register(kind, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search for users. The homeserver may determine which subset of users are searched, however the homeserver MUST at a minimum consider the users the requesting user shares a room with and those who reside in public rooms (known to the homeserver). The search MUST consider local users to the homeserver, and SHOULD query remote users as part of the search.  The search is performed case-insensitively on user IDs and display names preferably using a collation determined based upon the ``Accept-Language`` header provided in the request, if present.
         * @summary Searches the user directory.
         * @param {InlineObject39} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserDirectory(body?: InlineObject39, options?: any): AxiosPromise<InlineResponse20049> {
            return UserDataApiFp(configuration).searchUserDirectory(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Set some account_data for the client. This config is only visible to the user that set the account_data. The config will be synced to clients in the top-level ``account_data``.
         * @summary Set some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
         * @param {object} content The content of the account_data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountData(userId: string, type: string, content: object, options?: any): AxiosPromise<void> {
            return UserDataApiFp(configuration).setAccountData(userId, type, content, options).then((request) => request(axios, basePath));
        },
        /**
         * Set some account_data for the client on a given room. This config is only visible to the user that set the account_data. The config will be synced to clients in the per-room ``account_data``.
         * @summary Set some account_data for the user.
         * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to set account_data on.
         * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
         * @param {object} content The content of the account_data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountDataPerRoom(userId: string, roomId: string, type: string, content: object, options?: any): AxiosPromise<void> {
            return UserDataApiFp(configuration).setAccountDataPerRoom(userId, roomId, type, content, options).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the given user\'s avatar URL. You must have permission to set this user\'s avatar URL, e.g. you need to have their ``access_token``.
         * @summary Set the user\'s avatar URL.
         * @param {string} userId The user whose avatar URL to set.
         * @param {InlineObject18} avatarUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAvatarUrl(userId: string, avatarUrl: InlineObject18, options?: any): AxiosPromise<object> {
            return UserDataApiFp(configuration).setAvatarUrl(userId, avatarUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * This API sets the given user\'s display name. You must have permission to set this user\'s display name, e.g. you need to have their ``access_token``.
         * @summary Set the user\'s display name.
         * @param {string} userId The user whose display name to set.
         * @param {InlineObject19} displayName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDisplayName(userId: string, displayName: InlineObject19, options?: any): AxiosPromise<object> {
            return UserDataApiFp(configuration).setDisplayName(userId, displayName, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to the room.
         * @summary Add a tag to a room.
         * @param {string} userId The id of the user to add a tag for. The access token must be authorized to make requests for this user ID.
         * @param {string} roomId The ID of the room to add a tag to.
         * @param {string} tag The tag to add.
         * @param {InlineObject38} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomTag(userId: string, roomId: string, tag: string, body: InlineObject38, options?: any): AxiosPromise<object> {
            return UserDataApiFp(configuration).setRoomTag(userId, roomId, tag, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a user\'s third party identifier from the provided identity server without removing it from the homeserver.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
         * @summary Removes a user\'s third party identifier from an identity server.
         * @param {InlineObject3} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbind3pidFromAccount(body?: InlineObject3, options?: any): AxiosPromise<InlineResponse2002> {
            return UserDataApiFp(configuration).unbind3pidFromAccount(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserDataApi - object-oriented interface
 * @export
 * @class UserDataApi
 * @extends {BaseAPI}
 */
export class UserDataApi extends BaseAPI {
    /**
     * Binds a 3PID to the user\'s account through the specified identity server.  Homeservers should not prevent this request from succeeding if another user has bound the 3PID. Homeservers should simply proxy any errors received by the identity server to the caller.  Homeservers should track successful binds so they can be unbound later.
     * @summary Binds a 3PID to the user\'s account through an Identity Service.
     * @param {InlineObject1} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public bind3PID(body?: InlineObject1, options?: any) {
        return UserDataApiFp(this.configuration).bind3PID(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the password for an account on this homeserver.  This API endpoint uses the `User-Interactive Authentication API`_ to ensure the user changing the password is actually the owner of the account.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided. The homeserver SHOULD NOT revoke the access token provided in the request. Whether other access tokens for the user are revoked depends on the request parameters.
     * @summary Changes a user\'s password.
     * @param {InlineObject5} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public changePassword(body?: InlineObject5, options?: any) {
        return UserDataApiFp(this.configuration).changePassword(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks to see if a username is available, and valid, for the server.  The server should check to ensure that, at the time of the request, the username requested is available for use. This includes verifying that an application service has not claimed the username and that the username fits the server\'s desired requirements (for example, a server could dictate that it does not permit usernames with underscores).  Matrix clients may wish to use this API prior to attempting registration, however the clients must also be aware that using this API does not normally reserve the username. This can mean that the username becomes unavailable between checking its availability and attempting to register it.
     * @summary Checks to see if a username is available on the server.
     * @param {string} username The username to check the availability of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public checkUsernameAvailability(username: string, options?: any) {
        return UserDataApiFp(this.configuration).checkUsernameAvailability(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate the user\'s account, removing all ability for the user to login again.  This API endpoint uses the `User-Interactive Authentication API`_.  An access token should be submitted to this endpoint if the client has an active session.  The homeserver may change the flows available depending on whether a valid access token is provided.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
     * @summary Deactivate a user\'s account.
     * @param {InlineObject4} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public deactivateAccount(body?: InlineObject4, options?: any) {
        return UserDataApiFp(this.configuration).deactivateAccount(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a third party identifier from the user\'s account. This might not cause an unbind of the identifier from the identity server.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
     * @summary Deletes a third party identifier from the user\'s account
     * @param {InlineObject2} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public delete3pidFromAccount(body?: InlineObject2, options?: any) {
        return UserDataApiFp(this.configuration).delete3pidFromAccount(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from the room.
     * @summary Remove a tag from the room.
     * @param {string} userId The id of the user to remove a tag for. The access token must be authorized to make requests for this user ID.
     * @param {string} roomId The ID of the room to remove a tag from.
     * @param {string} tag The tag to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public deleteRoomTag(userId: string, roomId: string, tag: string, options?: any) {
        return UserDataApiFp(this.configuration).deleteRoomTag(userId, roomId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of the third party identifiers that the homeserver has associated with the user\'s account.  This is *not* the same as the list of third party identifiers bound to the user\'s Matrix ID in identity servers.  Identifiers in this list may be used by the homeserver as, for example, identifiers that it will accept to reset the user\'s account password.
     * @summary Gets a list of a user\'s third party identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getAccount3PIDs(options?: any) {
        return UserDataApiFp(this.configuration).getAccount3PIDs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get some account_data for the client. This config is only visible to the user that set the account_data.
     * @summary Get some account_data for the user.
     * @param {string} userId The ID of the user to get account_data for. The access token must be authorized to make requests for this user ID.
     * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getAccountData(userId: string, type: string, options?: any) {
        return UserDataApiFp(this.configuration).getAccountData(userId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get some account_data for the client on a given room. This config is only visible to the user that set the account_data.
     * @summary Get some account_data for the user.
     * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
     * @param {string} roomId The ID of the room to get account_data for.
     * @param {string} type The event type of the account_data to get. Custom types should be namespaced to avoid clashes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getAccountDataPerRoom(userId: string, roomId: string, type: string, options?: any) {
        return UserDataApiFp(this.configuration).getAccountDataPerRoom(userId, roomId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s avatar URL. This API may be used to fetch the user\'s own avatar URL or to query the URL of other users; either locally or on remote homeservers.
     * @summary Get the user\'s avatar URL.
     * @param {string} userId The user whose avatar URL to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getAvatarUrl(userId: string, options?: any) {
        return UserDataApiFp(this.configuration).getAvatarUrl(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s display name. This API may be used to fetch the user\'s own displayname or to query the name of other users; either locally or on remote homeservers.
     * @summary Get the user\'s display name.
     * @param {string} userId The user whose display name to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getDisplayName(userId: string, options?: any) {
        return UserDataApiFp(this.configuration).getDisplayName(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the tags set by a user on a room.
     * @summary List the tags for a room.
     * @param {string} userId The id of the user to get tags for. The access token must be authorized to make requests for this user ID.
     * @param {string} roomId The ID of the room to get tags for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getRoomTags(userId: string, roomId: string, options?: any) {
        return UserDataApiFp(this.configuration).getRoomTags(userId, roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information about the owner of a given access token.  Note that, as with the rest of the Client-Server API, Application Services may masquerade as users within their namespace by giving a ``user_id`` query parameter. In this situation, the server should verify that the given ``user_id`` is registered by the appservice, and return it in the response body.
     * @summary Gets information about the owner of an access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getTokenOwner(options?: any) {
        return UserDataApiFp(this.configuration).getTokenOwner(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the combined profile information for this user. This API may be used to fetch the user\'s own profile information or other users; either locally or on remote homeservers. This API may return keys which are not limited to ``displayname`` or ``avatar_url``.
     * @summary Get this user\'s profile information.
     * @param {string} userId The user whose profile information to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public getUserProfile(userId: string, options?: any) {
        return UserDataApiFp(this.configuration).getUserProfile(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds contact information to the user\'s account.  This endpoint is deprecated in favour of the more specific ``/3pid/add`` and ``/3pid/bind`` endpoints.  .. Note::    Previously this endpoint supported a ``bind`` parameter. This parameter    has been removed, making this endpoint behave as though it was ``false``.    This results in this endpoint being an equivalent to ``/3pid/bind`` rather    than dual-purpose.
     * @summary Adds contact information to the user\'s account.
     * @param {InlineObject} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public post3PIDs(body?: InlineObject, options?: any) {
        return UserDataApiFp(this.configuration).post3PIDs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint uses the `User-Interactive Authentication API`_, except in the cases where a guest account is being registered.  Register for an account on this homeserver.  There are two kinds of user account:  - `user` accounts. These accounts may use the full API described in this specification.  - `guest` accounts. These accounts may have limited permissions and may not be supported by all servers.  If registration is successful, this endpoint will issue an access token the client can use to authorize itself in subsequent requests.  If the client does not supply a ``device_id``, the server must auto-generate one.  The server SHOULD register an account with a User ID based on the ``username`` provided, if any. Note that the grammar of Matrix User ID localparts is restricted, so the server MUST either map the provided ``username`` onto a ``user_id`` in a logical manner, or reject ``username``\\s which do not comply to the grammar, with ``M_INVALID_USERNAME``.  Matrix clients MUST NOT assume that localpart of the registered ``user_id`` matches the provided ``username``.  The returned access token must be associated with the ``device_id`` supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device. See `Relationship between access tokens and devices`_.  When registering a guest account, all parameters in the request body with the exception of ``initial_device_display_name`` MUST BE ignored by the server. The server MUST pick a ``device_id`` for the account regardless of input.  Any user ID returned by this API must conform to the grammar given in the `Matrix specification <../appendices.html#user-identifiers>`_.
     * @summary Register for an account on this homeserver.
     * @param {'guest' | 'user'} [kind] The kind of account to register. Defaults to &#x60;&#x60;user&#x60;&#x60;.
     * @param {InlineObject25} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public register(kind?: 'guest' | 'user', body?: InlineObject25, options?: any) {
        return UserDataApiFp(this.configuration).register(kind, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search for users. The homeserver may determine which subset of users are searched, however the homeserver MUST at a minimum consider the users the requesting user shares a room with and those who reside in public rooms (known to the homeserver). The search MUST consider local users to the homeserver, and SHOULD query remote users as part of the search.  The search is performed case-insensitively on user IDs and display names preferably using a collation determined based upon the ``Accept-Language`` header provided in the request, if present.
     * @summary Searches the user directory.
     * @param {InlineObject39} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public searchUserDirectory(body?: InlineObject39, options?: any) {
        return UserDataApiFp(this.configuration).searchUserDirectory(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set some account_data for the client. This config is only visible to the user that set the account_data. The config will be synced to clients in the top-level ``account_data``.
     * @summary Set some account_data for the user.
     * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
     * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
     * @param {object} content The content of the account_data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public setAccountData(userId: string, type: string, content: object, options?: any) {
        return UserDataApiFp(this.configuration).setAccountData(userId, type, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set some account_data for the client on a given room. This config is only visible to the user that set the account_data. The config will be synced to clients in the per-room ``account_data``.
     * @summary Set some account_data for the user.
     * @param {string} userId The ID of the user to set account_data for. The access token must be authorized to make requests for this user ID.
     * @param {string} roomId The ID of the room to set account_data on.
     * @param {string} type The event type of the account_data to set. Custom types should be namespaced to avoid clashes.
     * @param {object} content The content of the account_data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public setAccountDataPerRoom(userId: string, roomId: string, type: string, content: object, options?: any) {
        return UserDataApiFp(this.configuration).setAccountDataPerRoom(userId, roomId, type, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the given user\'s avatar URL. You must have permission to set this user\'s avatar URL, e.g. you need to have their ``access_token``.
     * @summary Set the user\'s avatar URL.
     * @param {string} userId The user whose avatar URL to set.
     * @param {InlineObject18} avatarUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public setAvatarUrl(userId: string, avatarUrl: InlineObject18, options?: any) {
        return UserDataApiFp(this.configuration).setAvatarUrl(userId, avatarUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API sets the given user\'s display name. You must have permission to set this user\'s display name, e.g. you need to have their ``access_token``.
     * @summary Set the user\'s display name.
     * @param {string} userId The user whose display name to set.
     * @param {InlineObject19} displayName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public setDisplayName(userId: string, displayName: InlineObject19, options?: any) {
        return UserDataApiFp(this.configuration).setDisplayName(userId, displayName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to the room.
     * @summary Add a tag to a room.
     * @param {string} userId The id of the user to add a tag for. The access token must be authorized to make requests for this user ID.
     * @param {string} roomId The ID of the room to add a tag to.
     * @param {string} tag The tag to add.
     * @param {InlineObject38} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public setRoomTag(userId: string, roomId: string, tag: string, body: InlineObject38, options?: any) {
        return UserDataApiFp(this.configuration).setRoomTag(userId, roomId, tag, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a user\'s third party identifier from the provided identity server without removing it from the homeserver.  Unlike other endpoints, this endpoint does not take an ``id_access_token`` parameter because the homeserver is expected to sign the request to the identity server instead.
     * @summary Removes a user\'s third party identifier from an identity server.
     * @param {InlineObject3} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataApi
     */
    public unbind3pidFromAccount(body?: InlineObject3, options?: any) {
        return UserDataApiFp(this.configuration).unbind3pidFromAccount(body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VOIPApi - axios parameter creator
 * @export
 */
export const VOIPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API provides credentials for the client to use when initiating calls.
         * @summary Obtain TURN server credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTurnServer: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/_matrix/client/r0/voip/turnServer`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VOIPApi - functional programming interface
 * @export
 */
export const VOIPApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This API provides credentials for the client to use when initiating calls.
         * @summary Obtain TURN server credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTurnServer(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20050>> {
            const localVarAxiosArgs = await VOIPApiAxiosParamCreator(configuration).getTurnServer(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VOIPApi - factory interface
 * @export
 */
export const VOIPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This API provides credentials for the client to use when initiating calls.
         * @summary Obtain TURN server credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTurnServer(options?: any): AxiosPromise<InlineResponse20050> {
            return VOIPApiFp(configuration).getTurnServer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VOIPApi - object-oriented interface
 * @export
 * @class VOIPApi
 * @extends {BaseAPI}
 */
export class VOIPApi extends BaseAPI {
    /**
     * This API provides credentials for the client to use when initiating calls.
     * @summary Obtain TURN server credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VOIPApi
     */
    public getTurnServer(options?: any) {
        return VOIPApiFp(this.configuration).getTurnServer(options).then((request) => request(this.axios, this.basePath));
    }

}
